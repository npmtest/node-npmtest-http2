{"/home/travis/build/npmtest/node-npmtest-http2/test.js":"/* istanbul instrument in package npmtest_http2 */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-http2/lib.npmtest_http2.js":"/* istanbul instrument in package npmtest_http2 */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_http2 = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_http2 = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-http2/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-http2 && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_http2 */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_http2\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_http2.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_http2.rollup.js'] =\n            local.assetsDict['/assets.npmtest_http2.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_http2.__dirname + '/lib.npmtest_http2.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-http2/node_modules/http2/lib/index.js":"// [node-http2][homepage] is an [HTTP/2][http2] implementation for [node.js][node].\n//\n// The core of the protocol is implemented in the protocol sub-directory. This directory provides\n// two important features on top of the protocol:\n//\n// * Implementation of different negotiation schemes that can be used to start a HTTP2 connection.\n//   These include TLS ALPN, Upgrade and Plain TCP.\n//\n// * Providing an API very similar to the standard node.js [HTTPS module API][node-https]\n//   (which is in turn very similar to the [HTTP module API][node-http]).\n//\n// [homepage]:            https://github.com/molnarg/node-http2\n// [http2]:               https://tools.ietf.org/html/rfc7540\n// [node]:                https://nodejs.org/\n// [node-https]:          https://nodejs.org/api/https.html\n// [node-http]:           https://nodejs.org/api/http.html\n\nmodule.exports   = require('./http');\n\n/*\n                  HTTP API\n\n               |            ^\n               |            |\n +-------------|------------|------------------------------------------------------+\n |             |            |        Server/Agent                                  |\n |             v            |                                                      |\n |        +----------+ +----------+                                                |\n |        | Outgoing | | Incoming |                                                |\n |        | req/res. | | req/res. |                                                |\n |        +----------+ +----------+                                                |\n |             |            ^                                                      |\n |             |            |                                                      |\n |   +---------|------------|-------------------------------------+   +-----       |\n |   |         |            |   Endpoint                          |   |            |\n |   |         |            |                                     |   |            |\n |   |         v            |                                     |   |            |\n |   |    +-----------------------+  +--------------------        |   |            |\n |   |    |        Stream         |  |         Stream      ...    |   |            |\n |   |    +-----------------------+  +--------------------        |   |            |\n |   |                                                            |   |            |\n |   +------------------------------------------------------------+   +-----       |\n |                             |        |                                          |\n |                             |        |                                          |\n |                             v        |                                          |\n |   +------------------------------------------------------------+   +-----       |\n |   |                         TCP stream                         |   |      ...   |\n |   +------------------------------------------------------------+   +-----       |\n |                                                                                 |\n +---------------------------------------------------------------------------------+\n\n*/\n","/home/travis/build/npmtest/node-npmtest-http2/node_modules/http2/lib/http.js":"// Public API\n// ==========\n\n// The main governing power behind the http2 API design is that it should look very similar to the\n// existing node.js [HTTPS API][1] (which is, in turn, almost identical to the [HTTP API][2]). The\n// additional features of HTTP/2 are exposed as extensions to this API. Furthermore, node-http2\n// should fall back to using HTTP/1.1 if needed. Compatibility with undocumented or deprecated\n// elements of the node.js HTTP/HTTPS API is a non-goal.\n//\n// Additional and modified API elements\n// ------------------------------------\n//\n// - **Class: http2.Endpoint**: an API for using the raw HTTP/2 framing layer. For documentation\n//   see [protocol/endpoint.js](protocol/endpoint.html).\n//\n// - **Class: http2.Server**\n//   - **Event: 'connection' (socket, [endpoint])**: there's a second argument if the negotiation of\n//     HTTP/2 was successful: the reference to the [Endpoint](protocol/endpoint.html) object tied to the\n//     socket.\n//\n// - **http2.createServer(options, [requestListener])**: additional option:\n//   - **log**: an optional [bunyan](https://github.com/trentm/node-bunyan) logger object\n//\n// - **Class: http2.ServerResponse**\n//   - **response.push(options)**: initiates a server push. `options` describes the 'imaginary'\n//     request to which the push stream is a response; the possible options are identical to the\n//     ones accepted by `http2.request`. Returns a ServerResponse object that can be used to send\n//     the response headers and content.\n//\n// - **Class: http2.Agent**\n//   - **new Agent(options)**: additional option:\n//     - **log**: an optional [bunyan](https://github.com/trentm/node-bunyan) logger object\n//   - **agent.sockets**: only contains TCP sockets that corresponds to HTTP/1 requests.\n//   - **agent.endpoints**: contains [Endpoint](protocol/endpoint.html) objects for HTTP/2 connections.\n//\n// - **http2.request(options, [callback])**:\n//   - similar to http.request\n//\n// - **http2.get(options, [callback])**:\n//   - similar to http.get\n//\n// - **Class: http2.ClientRequest**\n//   - **Event: 'socket' (socket)**: in case of an HTTP/2 incoming message, `socket` is a reference\n//     to the associated [HTTP/2 Stream](protocol/stream.html) object (and not to the TCP socket).\n//   - **Event: 'push' (promise)**: signals the intention of a server push associated to this\n//     request. `promise` is an IncomingPromise. If there's no listener for this event, the server\n//     push is cancelled.\n//   - **request.setPriority(priority)**: assign a priority to this request. `priority` is a number\n//     between 0 (highest priority) and 2^31-1 (lowest priority). Default value is 2^30.\n//\n// - **Class: http2.IncomingMessage**\n//   - has two subclasses for easier interface description: **IncomingRequest** and\n//     **IncomingResponse**\n//   - **message.socket**: in case of an HTTP/2 incoming message, it's a reference to the associated\n//     [HTTP/2 Stream](protocol/stream.html) object (and not to the TCP socket).\n//\n// - **Class: http2.IncomingRequest (IncomingMessage)**\n//   - **message.url**: in case of an HTTP/2 incoming request, the `url` field always contains the\n//     path, and never a full url (it contains the path in most cases in the HTTPS api as well).\n//   - **message.scheme**: additional field. Mandatory HTTP/2 request metadata.\n//   - **message.host**: additional field. Mandatory HTTP/2 request metadata. Note that this\n//     replaces the old Host header field, but node-http2 will add Host to the `message.headers` for\n//     backwards compatibility.\n//\n// - **Class: http2.IncomingPromise (IncomingRequest)**\n//   - contains the metadata of the 'imaginary' request to which the server push is an answer.\n//   - **Event: 'response' (response)**: signals the arrival of the actual push stream. `response`\n//     is an IncomingResponse.\n//   - **Event: 'push' (promise)**: signals the intention of a server push associated to this\n//     request. `promise` is an IncomingPromise. If there's no listener for this event, the server\n//     push is cancelled.\n//   - **promise.cancel()**: cancels the promised server push.\n//   - **promise.setPriority(priority)**: assign a priority to this push stream. `priority` is a\n//     number between 0 (highest priority) and 2^31-1 (lowest priority). Default value is 2^30.\n//\n// API elements not yet implemented\n// --------------------------------\n//\n// - **Class: http2.Server**\n//   - **server.maxHeadersCount**\n//\n// API elements that are not applicable to HTTP/2\n// ----------------------------------------------\n//\n// The reason may be deprecation of certain HTTP/1.1 features, or that some API elements simply\n// don't make sense when using HTTP/2. These will not be present when a request is done with HTTP/2,\n// but will function normally when falling back to using HTTP/1.1.\n//\n// - **Class: http2.Server**\n//   - **Event: 'checkContinue'**: not in the spec\n//   - **Event: 'upgrade'**: upgrade is deprecated in HTTP/2\n//   - **Event: 'timeout'**: HTTP/2 sockets won't timeout because of application level keepalive\n//     (PING frames)\n//   - **Event: 'connect'**: not yet supported\n//   - **server.setTimeout(msecs, [callback])**\n//   - **server.timeout**\n//\n// - **Class: http2.ServerResponse**\n//   - **Event: 'close'**\n//   - **Event: 'timeout'**\n//   - **response.writeContinue()**\n//   - **response.writeHead(statusCode, [reasonPhrase], [headers])**: reasonPhrase will always be\n//     ignored since [it's not supported in HTTP/2][3]\n//   - **response.setTimeout(timeout, [callback])**\n//\n// - **Class: http2.Agent**\n//   - **agent.maxSockets**: only affects HTTP/1 connection pool. When using HTTP/2, there's always\n//     one connection per host.\n//\n// - **Class: http2.ClientRequest**\n//   - **Event: 'upgrade'**\n//   - **Event: 'connect'**\n//   - **Event: 'continue'**\n//   - **request.setTimeout(timeout, [callback])**\n//   - **request.setNoDelay([noDelay])**\n//   - **request.setSocketKeepAlive([enable], [initialDelay])**\n//\n// - **Class: http2.IncomingMessage**\n//   - **Event: 'close'**\n//   - **message.setTimeout(timeout, [callback])**\n//\n// [1]: https://nodejs.org/api/https.html\n// [2]: https://nodejs.org/api/http.html\n// [3]: https://tools.ietf.org/html/rfc7540#section-8.1.2.4\n\n// Common server and client side code\n// ==================================\n\nvar net = require('net');\nvar url = require('url');\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar PassThrough = require('stream').PassThrough;\nvar Readable = require('stream').Readable;\nvar Writable = require('stream').Writable;\nvar protocol = require('./protocol');\nvar Endpoint = protocol.Endpoint;\nvar http = require('http');\nvar https = require('https');\n\nexports.STATUS_CODES = http.STATUS_CODES;\nexports.IncomingMessage = IncomingMessage;\nexports.OutgoingMessage = OutgoingMessage;\nexports.protocol = protocol;\n\nvar deprecatedHeaders = [\n  'connection',\n  'host',\n  'keep-alive',\n  'proxy-connection',\n  'transfer-encoding',\n  'upgrade'\n];\n\n// When doing NPN/ALPN negotiation, HTTP/1.1 is used as fallback\nvar supportedProtocols = [protocol.VERSION, 'http/1.1', 'http/1.0'];\n\n// Ciphersuite list based on the recommendations of https://wiki.mozilla.org/Security/Server_Side_TLS\n// The only modification is that kEDH+AESGCM were placed after DHE and ECDHE suites\nvar cipherSuites = [\n  'ECDHE-RSA-AES128-GCM-SHA256',\n  'ECDHE-ECDSA-AES128-GCM-SHA256',\n  'ECDHE-RSA-AES256-GCM-SHA384',\n  'ECDHE-ECDSA-AES256-GCM-SHA384',\n  'DHE-RSA-AES128-GCM-SHA256',\n  'DHE-DSS-AES128-GCM-SHA256',\n  'ECDHE-RSA-AES128-SHA256',\n  'ECDHE-ECDSA-AES128-SHA256',\n  'ECDHE-RSA-AES128-SHA',\n  'ECDHE-ECDSA-AES128-SHA',\n  'ECDHE-RSA-AES256-SHA384',\n  'ECDHE-ECDSA-AES256-SHA384',\n  'ECDHE-RSA-AES256-SHA',\n  'ECDHE-ECDSA-AES256-SHA',\n  'DHE-RSA-AES128-SHA256',\n  'DHE-RSA-AES128-SHA',\n  'DHE-DSS-AES128-SHA256',\n  'DHE-RSA-AES256-SHA256',\n  'DHE-DSS-AES256-SHA',\n  'DHE-RSA-AES256-SHA',\n  'kEDH+AESGCM',\n  'AES128-GCM-SHA256',\n  'AES256-GCM-SHA384',\n  'ECDHE-RSA-RC4-SHA',\n  'ECDHE-ECDSA-RC4-SHA',\n  'AES128',\n  'AES256',\n  'RC4-SHA',\n  'HIGH',\n  '!aNULL',\n  '!eNULL',\n  '!EXPORT',\n  '!DES',\n  '!3DES',\n  '!MD5',\n  '!PSK'\n].join(':');\n\n// Logging\n// -------\n\n// Logger shim, used when no logger is provided by the user.\nfunction noop() {}\nvar defaultLogger = {\n  fatal: noop,\n  error: noop,\n  warn : noop,\n  info : noop,\n  debug: noop,\n  trace: noop,\n\n  child: function() { return this; }\n};\n\n// Bunyan serializers exported by submodules that are worth adding when creating a logger.\nexports.serializers = protocol.serializers;\n\n// IncomingMessage class\n// ---------------------\n\nfunction IncomingMessage(stream) {\n  // * This is basically a read-only wrapper for the [Stream](protocol/stream.html) class.\n  PassThrough.call(this);\n  stream.pipe(this);\n  this.socket = this.stream = stream;\n\n  this._log = stream._log.child({ component: 'http' });\n\n  // * HTTP/2.0 does not define a way to carry the version identifier that is included in the\n  //   HTTP/1.1 request/status line. Version is always 2.0.\n  this.httpVersion = '2.0';\n  this.httpVersionMajor = 2;\n  this.httpVersionMinor = 0;\n\n  // * `this.headers` will store the regular headers (and none of the special colon headers)\n  this.headers = {};\n  this.trailers = undefined;\n  this._lastHeadersSeen = undefined;\n\n  // * Other metadata is filled in when the headers arrive.\n  stream.once('headers', this._onHeaders.bind(this));\n  stream.once('end', this._onEnd.bind(this));\n}\nIncomingMessage.prototype = Object.create(PassThrough.prototype, { constructor: { value: IncomingMessage } });\n\n// [Request Header Fields](https://tools.ietf.org/html/rfc7540#section-8.1.2.3)\n// * `headers` argument: HTTP/2.0 request and response header fields carry information as a series\n//   of key-value pairs. This includes the target URI for the request, the status code for the\n//   response, as well as HTTP header fields.\nIncomingMessage.prototype._onHeaders = function _onHeaders(headers) {\n  // * Detects malformed headers\n  this._validateHeaders(headers);\n\n  // * Store the _regular_ headers in `this.headers`\n  for (var name in headers) {\n    if (name[0] !== ':') {\n      if (name === 'set-cookie' && !Array.isArray(headers[name])) {\n        this.headers[name] = [headers[name]];\n      } else {\n        this.headers[name] = headers[name];\n      }\n    }\n  }\n\n  // * The last header block, if it's not the first, will represent the trailers\n  var self = this;\n  this.stream.on('headers', function(headers) {\n    self._lastHeadersSeen = headers;\n  });\n};\n\nIncomingMessage.prototype._onEnd = function _onEnd() {\n  this.trailers = this._lastHeadersSeen;\n};\n\nIncomingMessage.prototype.setTimeout = noop;\n\nIncomingMessage.prototype._checkSpecialHeader = function _checkSpecialHeader(key, value) {\n  if ((typeof value !== 'string') || (value.length === 0)) {\n    this._log.error({ key: key, value: value }, 'Invalid or missing special header field');\n    this.stream.reset('PROTOCOL_ERROR');\n  }\n\n  return value;\n};\n\nIncomingMessage.prototype._validateHeaders = function _validateHeaders(headers) {\n  // * An HTTP/2.0 request or response MUST NOT include any of the following header fields:\n  //   Connection, Host, Keep-Alive, Proxy-Connection, Transfer-Encoding, and Upgrade. A server\n  //   MUST treat the presence of any of these header fields as a stream error of type\n  //   PROTOCOL_ERROR.\n  //  If the TE header is present, it's only valid value is 'trailers'\n  for (var i = 0; i < deprecatedHeaders.length; i++) {\n    var key = deprecatedHeaders[i];\n    if (key in headers || (key === 'te' && headers[key] !== 'trailers')) {\n      this._log.error({ key: key, value: headers[key] }, 'Deprecated header found');\n      this.stream.reset('PROTOCOL_ERROR');\n      return;\n    }\n  }\n\n  for (var headerName in headers) {\n    // * Empty header name field is malformed\n    if (headerName.length <= 1) {\n      this.stream.reset('PROTOCOL_ERROR');\n      return;\n    }\n    // * A request or response containing uppercase header name field names MUST be\n    //   treated as malformed (Section 8.1.3.5). Implementations that detect malformed\n    //   requests or responses need to ensure that the stream ends.\n    if(/[A-Z]/.test(headerName)) {\n      this.stream.reset('PROTOCOL_ERROR');\n      return;\n    }\n  }\n};\n\n// OutgoingMessage class\n// ---------------------\n\nfunction OutgoingMessage() {\n  // * This is basically a read-only wrapper for the [Stream](protocol/stream.html) class.\n  Writable.call(this);\n\n  this._headers = {};\n  this._trailers = undefined;\n  this.headersSent = false;\n  this.finished = false;\n\n  this.on('finish', this._finish);\n}\nOutgoingMessage.prototype = Object.create(Writable.prototype, { constructor: { value: OutgoingMessage } });\n\nOutgoingMessage.prototype._write = function _write(chunk, encoding, callback) {\n  if (this.stream) {\n    this.stream.write(chunk, encoding, callback);\n  } else {\n    this.once('socket', this._write.bind(this, chunk, encoding, callback));\n  }\n};\n\nOutgoingMessage.prototype._finish = function _finish() {\n  if (this.stream) {\n    if (this._trailers) {\n      if (this.request) {\n        this.request.addTrailers(this._trailers);\n      } else {\n        this.stream.headers(this._trailers);\n      }\n    }\n    this.finished = true;\n    this.stream.end();\n  } else {\n    this.once('socket', this._finish.bind(this));\n  }\n};\n\nOutgoingMessage.prototype.setHeader = function setHeader(name, value) {\n  if (this.headersSent) {\n    return this.emit('error', new Error('Can\\'t set headers after they are sent.'));\n  } else {\n    name = name.toLowerCase();\n    if (deprecatedHeaders.indexOf(name) !== -1) {\n      return this.emit('error', new Error('Cannot set deprecated header: ' + name));\n    }\n    this._headers[name] = value;\n  }\n};\n\nOutgoingMessage.prototype.removeHeader = function removeHeader(name) {\n  if (this.headersSent) {\n    return this.emit('error', new Error('Can\\'t remove headers after they are sent.'));\n  } else {\n    delete this._headers[name.toLowerCase()];\n  }\n};\n\nOutgoingMessage.prototype.getHeader = function getHeader(name) {\n  return this._headers[name.toLowerCase()];\n};\n\nOutgoingMessage.prototype.addTrailers = function addTrailers(trailers) {\n  this._trailers = trailers;\n};\n\nOutgoingMessage.prototype.setTimeout = noop;\n\nOutgoingMessage.prototype._checkSpecialHeader = IncomingMessage.prototype._checkSpecialHeader;\n\n// Server side\n// ===========\n\nexports.Server = Server;\nexports.IncomingRequest = IncomingRequest;\nexports.OutgoingResponse = OutgoingResponse;\nexports.ServerResponse = OutgoingResponse; // for API compatibility\n\n// Forward events `event` on `source` to all listeners on `target`.\n//\n// Note: The calling context is `source`.\nfunction forwardEvent(event, source, target) {\n  function forward() {\n    var listeners = target.listeners(event);\n\n    var n = listeners.length;\n\n    // Special case for `error` event with no listeners.\n    if (n === 0 && event === 'error') {\n      var args = [event];\n      args.push.apply(args, arguments);\n\n      target.emit.apply(target, args);\n      return;\n    }\n\n    for (var i = 0; i < n; ++i) {\n      listeners[i].apply(source, arguments);\n    }\n  }\n\n  source.on(event, forward);\n\n  // A reference to the function is necessary to be able to stop\n  // forwarding.\n  return forward;\n}\n\n// Server class\n// ------------\n\nfunction Server(options) {\n  options = util._extend({}, options);\n\n  this._log = (options.log || defaultLogger).child({ component: 'http' });\n  this._settings = options.settings;\n\n  var start = this._start.bind(this);\n  var fallback = this._fallback.bind(this);\n\n  // HTTP2 over TLS (using NPN or ALPN)\n  if ((options.key && options.cert) || options.pfx) {\n    this._log.info('Creating HTTP/2 server over TLS');\n    this._mode = 'tls';\n    options.ALPNProtocols = supportedProtocols;\n    options.NPNProtocols = supportedProtocols;\n    options.ciphers = options.ciphers || cipherSuites;\n    options.honorCipherOrder = (options.honorCipherOrder != false);\n    this._server = https.createServer(options);\n    this._originalSocketListeners = this._server.listeners('secureConnection');\n    this._server.removeAllListeners('secureConnection');\n    this._server.on('secureConnection', function(socket) {\n      var negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol;\n      // It's true that the client MUST use SNI, but if it doesn't, we don't care, don't fall back to HTTP/1,\n      // since if the ALPN negotiation is otherwise successful, the client thinks we speak HTTP/2 but we don't.\n      if (negotiatedProtocol === protocol.VERSION) {\n        start(socket);\n      } else {\n        fallback(socket);\n      }\n    });\n    this._server.on('request', this.emit.bind(this, 'request'));\n\n    forwardEvent('error', this._server, this);\n    forwardEvent('listening', this._server, this);\n  }\n\n  // HTTP2 over plain TCP\n  else if (options.plain) {\n    this._log.info('Creating HTTP/2 server over plain TCP');\n    this._mode = 'plain';\n    this._server = net.createServer(start);\n  }\n\n  // HTTP/2 with HTTP/1.1 upgrade\n  else {\n    this._log.error('Trying to create HTTP/2 server with Upgrade from HTTP/1.1');\n    throw new Error('HTTP1.1 -> HTTP2 upgrade is not yet supported. Please provide TLS keys.');\n  }\n\n  this._server.on('close', this.emit.bind(this, 'close'));\n}\nServer.prototype = Object.create(EventEmitter.prototype, { constructor: { value: Server } });\n\n// Starting HTTP/2\nServer.prototype._start = function _start(socket) {\n  var endpoint = new Endpoint(this._log, 'SERVER', this._settings);\n\n  this._log.info({ e: endpoint,\n                   client: socket.remoteAddress + ':' + socket.remotePort,\n                   SNI: socket.servername\n                 }, 'New incoming HTTP/2 connection');\n\n  endpoint.pipe(socket).pipe(endpoint);\n\n  var self = this;\n  endpoint.on('stream', function _onStream(stream) {\n    var response = new OutgoingResponse(stream);\n    var request = new IncomingRequest(stream);\n\n    // Some conformance to Node.js Https specs allows to distinguish clients:\n    request.remoteAddress = socket.remoteAddress;\n    request.remotePort = socket.remotePort;\n    request.connection = request.socket = response.socket = socket;\n\n    request.once('ready', self.emit.bind(self, 'request', request, response));\n  });\n\n  endpoint.on('error', this.emit.bind(this, 'clientError'));\n  socket.on('error', this.emit.bind(this, 'clientError'));\n\n  this.emit('connection', socket, endpoint);\n};\n\nServer.prototype._fallback = function _fallback(socket) {\n  var negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol;\n\n  this._log.info({ client: socket.remoteAddress + ':' + socket.remotePort,\n                   protocol: negotiatedProtocol,\n                   SNI: socket.servername\n                 }, 'Falling back to simple HTTPS');\n\n  for (var i = 0; i < this._originalSocketListeners.length; i++) {\n    this._originalSocketListeners[i].call(this._server, socket);\n  }\n\n  this.emit('connection', socket);\n};\n\n// There are [3 possible signatures][1] of the `listen` function. Every arguments is forwarded to\n// the backing TCP or HTTPS server.\n// [1]: https://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback\nServer.prototype.listen = function listen(port, hostname) {\n  this._log.info({ on: ((typeof hostname === 'string') ? (hostname + ':' + port) : port) },\n                 'Listening for incoming connections');\n  this._server.listen.apply(this._server, arguments);\n\n  return this._server;\n};\n\nServer.prototype.close = function close(callback) {\n  this._log.info('Closing server');\n  this._server.close(callback);\n};\n\nServer.prototype.setTimeout = function setTimeout(timeout, callback) {\n  if (this._mode === 'tls') {\n    this._server.setTimeout(timeout, callback);\n  }\n};\n\nObject.defineProperty(Server.prototype, 'timeout', {\n  get: function getTimeout() {\n    if (this._mode === 'tls') {\n      return this._server.timeout;\n    } else {\n      return undefined;\n    }\n  },\n  set: function setTimeout(timeout) {\n    if (this._mode === 'tls') {\n      this._server.timeout = timeout;\n    }\n  }\n});\n\n// Overriding `EventEmitter`'s `on(event, listener)` method to forward certain subscriptions to\n// `server`.There are events on the `http.Server` class where it makes difference whether someone is\n// listening on the event or not. In these cases, we can not simply forward the events from the\n// `server` to `this` since that means a listener. Instead, we forward the subscriptions.\nServer.prototype.on = function on(event, listener) {\n  if ((event === 'upgrade') || (event === 'timeout')) {\n    return this._server.on(event, listener && listener.bind(this));\n  } else {\n    return EventEmitter.prototype.on.call(this, event, listener);\n  }\n};\n\n// `addContext` is used to add Server Name Indication contexts\nServer.prototype.addContext = function addContext(hostname, credentials) {\n  if (this._mode === 'tls') {\n    this._server.addContext(hostname, credentials);\n  }\n};\n\nServer.prototype.address = function address() {\n  return this._server.address()\n};\n\nfunction createServerRaw(options, requestListener) {\n  if (typeof options === 'function') {\n    requestListener = options;\n    options = {};\n  }\n\n  if (options.pfx || (options.key && options.cert)) {\n    throw new Error('options.pfx, options.key, and options.cert are nonsensical!');\n  }\n\n  options.plain = true;\n  var server = new Server(options);\n\n  if (requestListener) {\n    server.on('request', requestListener);\n  }\n\n  return server;\n}\n\nfunction createServerTLS(options, requestListener) {\n  if (typeof options === 'function') {\n    throw new Error('options are required!');\n  }\n  if (!options.pfx && !(options.key && options.cert)) {\n    throw new Error('options.pfx or options.key and options.cert are required!');\n  }\n  options.plain = false;\n\n  var server = new Server(options);\n\n  if (requestListener) {\n    server.on('request', requestListener);\n  }\n\n  return server;\n}\n\n// Exposed main interfaces for HTTPS connections (the default)\nexports.https = {};\nexports.createServer = exports.https.createServer = createServerTLS;\nexports.request = exports.https.request = requestTLS;\nexports.get = exports.https.get = getTLS;\n\n// Exposed main interfaces for raw TCP connections (not recommended)\nexports.raw = {};\nexports.raw.createServer = createServerRaw;\nexports.raw.request = requestRaw;\nexports.raw.get = getRaw;\n\n// Exposed main interfaces for HTTP plaintext upgrade connections (not implemented)\nfunction notImplemented() {\n    throw new Error('HTTP UPGRADE is not implemented!');\n}\n\nexports.http = {};\nexports.http.createServer = exports.http.request = exports.http.get = notImplemented;\n\n// IncomingRequest class\n// ---------------------\n\nfunction IncomingRequest(stream) {\n  IncomingMessage.call(this, stream);\n}\nIncomingRequest.prototype = Object.create(IncomingMessage.prototype, { constructor: { value: IncomingRequest } });\n\n// [Request Header Fields](https://tools.ietf.org/html/rfc7540#section-8.1.2.3)\n// * `headers` argument: HTTP/2.0 request and response header fields carry information as a series\n//   of key-value pairs. This includes the target URI for the request, the status code for the\n//   response, as well as HTTP header fields.\nIncomingRequest.prototype._onHeaders = function _onHeaders(headers) {\n  // * The \":method\" header field includes the HTTP method\n  // * The \":scheme\" header field includes the scheme portion of the target URI\n  // * The \":authority\" header field includes the authority portion of the target URI\n  // * The \":path\" header field includes the path and query parts of the target URI.\n  //   This field MUST NOT be empty; URIs that do not contain a path component MUST include a value\n  //   of '/', unless the request is an OPTIONS request for '*', in which case the \":path\" header\n  //   field MUST include '*'.\n  // * All HTTP/2.0 requests MUST include exactly one valid value for all of these header fields. A\n  //   server MUST treat the absence of any of these header fields, presence of multiple values, or\n  //   an invalid value as a stream error of type PROTOCOL_ERROR.\n  this.method = this._checkSpecialHeader(':method'   , headers[':method']);\n  this.scheme = this._checkSpecialHeader(':scheme'   , headers[':scheme']);\n  this.host   = this._checkSpecialHeader(':authority', headers[':authority']  );\n  this.url    = this._checkSpecialHeader(':path'     , headers[':path']  );\n  if (!this.method || !this.scheme || !this.host || !this.url) {\n    // This is invalid, and we've sent a RST_STREAM, so don't continue processing\n    return;\n  }\n\n  // * Host header is included in the headers object for backwards compatibility.\n  this.headers.host = this.host;\n\n  // * Handling regular headers.\n  IncomingMessage.prototype._onHeaders.call(this, headers);\n\n  // * Signaling that the headers arrived.\n  this._log.info({ method: this.method, scheme: this.scheme, host: this.host,\n                   path: this.url, headers: this.headers }, 'Incoming request');\n  this.emit('ready');\n};\n\n// OutgoingResponse class\n// ----------------------\n\nfunction OutgoingResponse(stream) {\n  OutgoingMessage.call(this);\n\n  this._log = stream._log.child({ component: 'http' });\n\n  this.stream = stream;\n  this.statusCode = 200;\n  this.sendDate = true;\n\n  this.stream.once('headers', this._onRequestHeaders.bind(this));\n}\nOutgoingResponse.prototype = Object.create(OutgoingMessage.prototype, { constructor: { value: OutgoingResponse } });\n\nOutgoingResponse.prototype.writeHead = function writeHead(statusCode, reasonPhrase, headers) {\n  if (this.headersSent) {\n    return;\n  }\n\n  if (typeof reasonPhrase === 'string') {\n    this._log.warn('Reason phrase argument was present but ignored by the writeHead method');\n  } else {\n    headers = reasonPhrase;\n  }\n\n  for (var name in headers) {\n    this.setHeader(name, headers[name]);\n  }\n  headers = this._headers;\n\n  if (this.sendDate && !('date' in this._headers)) {\n    headers.date = (new Date()).toUTCString();\n  }\n\n  this._log.info({ status: statusCode, headers: this._headers }, 'Sending server response');\n\n  headers[':status'] = this.statusCode = statusCode;\n\n  this.stream.headers(headers);\n  this.headersSent = true;\n};\n\nOutgoingResponse.prototype._implicitHeaders = function _implicitHeaders() {\n  if (!this.headersSent) {\n    this.writeHead(this.statusCode);\n  }\n};\n\nOutgoingResponse.prototype._implicitHeader = function() {\n  this._implicitHeaders();\n};\n\nOutgoingResponse.prototype.write = function write() {\n  this._implicitHeaders();\n  return OutgoingMessage.prototype.write.apply(this, arguments);\n};\n\nOutgoingResponse.prototype.end = function end() {\n  this.finshed = true;\n  this._implicitHeaders();\n  return OutgoingMessage.prototype.end.apply(this, arguments);\n};\n\nOutgoingResponse.prototype._onRequestHeaders = function _onRequestHeaders(headers) {\n  this._requestHeaders = headers;\n};\n\nOutgoingResponse.prototype.push = function push(options) {\n  if (typeof options === 'string') {\n    options = url.parse(options);\n  }\n\n  if (!options.path) {\n    throw new Error('`path` option is mandatory.');\n  }\n\n  var promise = util._extend({\n    ':method': (options.method || 'GET').toUpperCase(),\n    ':scheme': (options.protocol && options.protocol.slice(0, -1)) || this._requestHeaders[':scheme'],\n    ':authority': options.hostname || options.host || this._requestHeaders[':authority'],\n    ':path': options.path\n  }, options.headers);\n\n  this._log.info({ method: promise[':method'], scheme: promise[':scheme'],\n                   authority: promise[':authority'], path: promise[':path'],\n                   headers: options.headers }, 'Promising push stream');\n\n  var pushStream = this.stream.promise(promise);\n\n  return new OutgoingResponse(pushStream);\n};\n\nOutgoingResponse.prototype.altsvc = function altsvc(host, port, protocolID, maxAge, origin) {\n    if (origin === undefined) {\n        origin = \"\";\n    }\n    this.stream.altsvc(host, port, protocolID, maxAge, origin);\n};\n\n// Overriding `EventEmitter`'s `on(event, listener)` method to forward certain subscriptions to\n// `request`. See `Server.prototype.on` for explanation.\nOutgoingResponse.prototype.on = function on(event, listener) {\n  if (this.request && (event === 'timeout')) {\n    this.request.on(event, listener && listener.bind(this));\n  } else {\n    OutgoingMessage.prototype.on.call(this, event, listener);\n  }\n};\n\n// Client side\n// ===========\n\nexports.ClientRequest = OutgoingRequest; // for API compatibility\nexports.OutgoingRequest = OutgoingRequest;\nexports.IncomingResponse = IncomingResponse;\nexports.Agent = Agent;\nexports.globalAgent = undefined;\n\nfunction requestRaw(options, callback) {\n  if (typeof options === \"string\") {\n    options = url.parse(options);\n  }\n  options.plain = true;\n  if (options.protocol && options.protocol !== \"http:\") {\n    throw new Error('This interface only supports http-schemed URLs');\n  }\n  if (options.agent && typeof(options.agent.request) === 'function') {\n    var agentOptions = util._extend({}, options);\n    delete agentOptions.agent;\n    return options.agent.request(agentOptions, callback);\n  }\n  return exports.globalAgent.request(options, callback);\n}\n\nfunction requestTLS(options, callback) {\n  if (typeof options === \"string\") {\n    options = url.parse(options);\n  }\n  options.plain = false;\n  if (options.protocol && options.protocol !== \"https:\") {\n    throw new Error('This interface only supports https-schemed URLs');\n  }\n  if (options.agent && typeof(options.agent.request) === 'function') {\n    var agentOptions = util._extend({}, options);\n    delete agentOptions.agent;\n    return options.agent.request(agentOptions, callback);\n  }\n  return exports.globalAgent.request(options, callback);\n}\n\nfunction getRaw(options, callback) {\n  if (typeof options === \"string\") {\n    options = url.parse(options);\n  }\n  options.plain = true;\n  if (options.protocol && options.protocol !== \"http:\") {\n    throw new Error('This interface only supports http-schemed URLs');\n  }\n  if (options.agent && typeof(options.agent.get) === 'function') {\n    var agentOptions = util._extend({}, options);\n    delete agentOptions.agent;\n    return options.agent.get(agentOptions, callback);\n  }\n  return exports.globalAgent.get(options, callback);\n}\n\nfunction getTLS(options, callback) {\n  if (typeof options === \"string\") {\n    options = url.parse(options);\n  }\n  options.plain = false;\n  if (options.protocol && options.protocol !== \"https:\") {\n    throw new Error('This interface only supports https-schemed URLs');\n  }\n  if (options.agent && typeof(options.agent.get) === 'function') {\n    var agentOptions = util._extend({}, options);\n    delete agentOptions.agent;\n    return options.agent.get(agentOptions, callback);\n  }\n  return exports.globalAgent.get(options, callback);\n}\n\n// Agent class\n// -----------\n\nfunction Agent(options) {\n  EventEmitter.call(this);\n  this.setMaxListeners(0);\n\n  options = util._extend({}, options);\n\n  this._settings = options.settings;\n  this._log = (options.log || defaultLogger).child({ component: 'http' });\n  this.endpoints = {};\n\n  // * Using an own HTTPS agent, because the global agent does not look at `NPN/ALPNProtocols` when\n  //   generating the key identifying the connection, so we may get useless non-negotiated TLS\n  //   channels even if we ask for a negotiated one. This agent will contain only negotiated\n  //   channels.\n  options.ALPNProtocols = supportedProtocols;\n  options.NPNProtocols = supportedProtocols;\n  this._httpsAgent = new https.Agent(options);\n\n  this.sockets = this._httpsAgent.sockets;\n  this.requests = this._httpsAgent.requests;\n}\nAgent.prototype = Object.create(EventEmitter.prototype, { constructor: { value: Agent } });\n\nAgent.prototype.request = function request(options, callback) {\n  if (typeof options === 'string') {\n    options = url.parse(options);\n  } else {\n    options = util._extend({}, options);\n  }\n\n  options.method = (options.method || 'GET').toUpperCase();\n  options.protocol = options.protocol || 'https:';\n  options.host = options.hostname || options.host || 'localhost';\n  options.port = options.port || 443;\n  options.path = options.path || '/';\n\n  if (!options.plain && options.protocol === 'http:') {\n    this._log.error('Trying to negotiate client request with Upgrade from HTTP/1.1');\n    this.emit('error', new Error('HTTP1.1 -> HTTP2 upgrade is not yet supported.'));\n  }\n\n  var request = new OutgoingRequest(this._log);\n\n  if (callback) {\n    request.on('response', callback);\n  }\n\n  var key = [\n    !!options.plain,\n    options.host,\n    options.port\n  ].join(':');\n  var self = this;\n\n  // * There's an existing HTTP/2 connection to this host\n  if (key in this.endpoints) {\n    var endpoint = this.endpoints[key];\n    request._start(endpoint.createStream(), options);\n  }\n\n  // * HTTP/2 over plain TCP\n  else if (options.plain) {\n    endpoint = new Endpoint(this._log, 'CLIENT', this._settings);\n    endpoint.socket = net.connect({\n      host: options.host,\n      port: options.port,\n      localAddress: options.localAddress\n    });\n\n    endpoint.socket.on('error', function (error) {\n      self._log.error('Socket error: ' + error.toString());\n      request.emit('error', error);\n    });\n\n    endpoint.on('error', function(error){\n      self._log.error('Connection error: ' + error.toString());\n      request.emit('error', error);\n    });\n\n    this.endpoints[key] = endpoint;\n    endpoint.pipe(endpoint.socket).pipe(endpoint);\n    request._start(endpoint.createStream(), options);\n  }\n\n  // * HTTP/2 over TLS negotiated using NPN or ALPN, or fallback to HTTPS1\n  else {\n    var started = false;\n    var createAgent = hasAgentOptions(options);\n    options.ALPNProtocols = supportedProtocols;\n    options.NPNProtocols = supportedProtocols;\n    options.servername = options.host; // Server Name Indication\n    options.ciphers = options.ciphers || cipherSuites;\n    if (createAgent) {\n      options.agent = new https.Agent(options);\n    } else if (options.agent == null) {\n      options.agent = this._httpsAgent;\n    }\n    var httpsRequest = https.request(options);\n\n    httpsRequest.on('error', function (error) {\n      self._log.error('Socket error: ' + error.toString());\n      self.removeAllListeners(key);\n      request.emit('error', error);\n    });\n\n    httpsRequest.on('socket', function(socket) {\n      var negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol;\n      if (negotiatedProtocol != null) { // null in >=0.11.0, undefined in <0.11.0\n        negotiated();\n      } else {\n        socket.on('secureConnect', negotiated);\n      }\n    });\n\n    function negotiated() {\n      var endpoint;\n      var negotiatedProtocol = httpsRequest.socket.alpnProtocol || httpsRequest.socket.npnProtocol;\n      if (negotiatedProtocol === protocol.VERSION) {\n        httpsRequest.socket.emit('agentRemove');\n        unbundleSocket(httpsRequest.socket);\n        endpoint = new Endpoint(self._log, 'CLIENT', self._settings);\n        endpoint.socket = httpsRequest.socket;\n        endpoint.pipe(endpoint.socket).pipe(endpoint);\n      }\n      if (started) {\n        // ** In the meantime, an other connection was made to the same host...\n        if (endpoint) {\n          // *** and it turned out to be HTTP2 and the request was multiplexed on that one, so we should close this one\n          endpoint.close();\n        }\n        // *** otherwise, the fallback to HTTPS1 is already done.\n      } else {\n        if (endpoint) {\n          self._log.info({ e: endpoint, server: options.host + ':' + options.port },\n                         'New outgoing HTTP/2 connection');\n          self.endpoints[key] = endpoint;\n          self.emit(key, endpoint);\n        } else {\n          self.emit(key, undefined);\n        }\n      }\n    }\n\n    this.once(key, function(endpoint) {\n      started = true;\n      if (endpoint) {\n        request._start(endpoint.createStream(), options);\n      } else {\n        request._fallback(httpsRequest);\n      }\n    });\n  }\n\n  return request;\n};\n\nAgent.prototype.get = function get(options, callback) {\n  var request = this.request(options, callback);\n  request.end();\n  return request;\n};\n\nAgent.prototype.destroy = function(error) {\n  if (this._httpsAgent) {\n    this._httpsAgent.destroy();\n  }\n  for (var key in this.endpoints) {\n    this.endpoints[key].close(error);\n  }\n};\n\nfunction unbundleSocket(socket) {\n  socket.removeAllListeners('data');\n  socket.removeAllListeners('end');\n  socket.removeAllListeners('readable');\n  socket.removeAllListeners('close');\n  socket.removeAllListeners('error');\n  socket.unpipe();\n  delete socket.ondata;\n  delete socket.onend;\n}\n\nfunction hasAgentOptions(options) {\n  return options.pfx != null ||\n    options.key != null ||\n    options.passphrase != null ||\n    options.cert != null ||\n    options.ca != null ||\n    options.ciphers != null ||\n    options.rejectUnauthorized != null ||\n    options.secureProtocol != null;\n}\n\nObject.defineProperty(Agent.prototype, 'maxSockets', {\n  get: function getMaxSockets() {\n    return this._httpsAgent.maxSockets;\n  },\n  set: function setMaxSockets(value) {\n    this._httpsAgent.maxSockets = value;\n  }\n});\n\nexports.globalAgent = new Agent();\n\n// OutgoingRequest class\n// ---------------------\n\nfunction OutgoingRequest() {\n  OutgoingMessage.call(this);\n\n  this._log = undefined;\n\n  this.stream = undefined;\n}\nOutgoingRequest.prototype = Object.create(OutgoingMessage.prototype, { constructor: { value: OutgoingRequest } });\n\nOutgoingRequest.prototype._start = function _start(stream, options) {\n  this.stream = stream;\n  this.options = options;\n\n  this._log = stream._log.child({ component: 'http' });\n\n  for (var key in options.headers) {\n    this.setHeader(key, options.headers[key]);\n  }\n  var headers = this._headers;\n  delete headers.host;\n\n  if (options.auth) {\n    headers.authorization = 'Basic ' + new Buffer(options.auth).toString('base64');\n  }\n\n  headers[':scheme'] = options.protocol.slice(0, -1);\n  headers[':method'] = options.method;\n  headers[':authority'] = options.host;\n  headers[':path'] = options.path;\n\n  this._log.info({ scheme: headers[':scheme'], method: headers[':method'],\n                   authority: headers[':authority'], path: headers[':path'],\n                   headers: (options.headers || {}) }, 'Sending request');\n  this.stream.headers(headers);\n  this.headersSent = true;\n\n  this.emit('socket', this.stream);\n  var response = new IncomingResponse(this.stream);\n  response.req = this;\n  response.once('ready', this.emit.bind(this, 'response', response));\n\n  this.stream.on('promise', this._onPromise.bind(this));\n};\n\nOutgoingRequest.prototype._fallback = function _fallback(request) {\n  request.on('response', this.emit.bind(this, 'response'));\n  this.stream = this.request = request;\n  this.emit('socket', this.socket);\n};\n\nOutgoingRequest.prototype.setPriority = function setPriority(priority) {\n  if (this.stream) {\n    this.stream.priority(priority);\n  } else {\n    this.once('socket', this.setPriority.bind(this, priority));\n  }\n};\n\n// Overriding `EventEmitter`'s `on(event, listener)` method to forward certain subscriptions to\n// `request`. See `Server.prototype.on` for explanation.\nOutgoingRequest.prototype.on = function on(event, listener) {\n  if (this.request && (event === 'upgrade')) {\n    this.request.on(event, listener && listener.bind(this));\n  } else {\n    OutgoingMessage.prototype.on.call(this, event, listener);\n  }\n};\n\n// Methods only in fallback mode\nOutgoingRequest.prototype.setNoDelay = function setNoDelay(noDelay) {\n  if (this.request) {\n    this.request.setNoDelay(noDelay);\n  } else if (!this.stream) {\n    this.on('socket', this.setNoDelay.bind(this, noDelay));\n  }\n};\n\nOutgoingRequest.prototype.setSocketKeepAlive = function setSocketKeepAlive(enable, initialDelay) {\n  if (this.request) {\n    this.request.setSocketKeepAlive(enable, initialDelay);\n  } else if (!this.stream) {\n    this.on('socket', this.setSocketKeepAlive.bind(this, enable, initialDelay));\n  }\n};\n\nOutgoingRequest.prototype.setTimeout = function setTimeout(timeout, callback) {\n  if (this.request) {\n    this.request.setTimeout(timeout, callback);\n  } else if (!this.stream) {\n    this.on('socket', this.setTimeout.bind(this, timeout, callback));\n  }\n};\n\n// Aborting the request\nOutgoingRequest.prototype.abort = function abort() {\n  if (this.request) {\n    this.request.abort();\n  } else if (this.stream) {\n    this.stream.reset('CANCEL');\n  } else {\n    this.on('socket', this.abort.bind(this));\n  }\n};\n\n// Receiving push promises\nOutgoingRequest.prototype._onPromise = function _onPromise(stream, headers) {\n  this._log.info({ push_stream: stream.id }, 'Receiving push promise');\n\n  var promise = new IncomingPromise(stream, headers);\n\n  if (this.listeners('push').length > 0) {\n    this.emit('push', promise);\n  } else {\n    promise.cancel();\n  }\n};\n\n// IncomingResponse class\n// ----------------------\n\nfunction IncomingResponse(stream) {\n  IncomingMessage.call(this, stream);\n}\nIncomingResponse.prototype = Object.create(IncomingMessage.prototype, { constructor: { value: IncomingResponse } });\n\n// [Response Header Fields](https://tools.ietf.org/html/rfc7540#section-8.1.2.4)\n// * `headers` argument: HTTP/2.0 request and response header fields carry information as a series\n//   of key-value pairs. This includes the target URI for the request, the status code for the\n//   response, as well as HTTP header fields.\nIncomingResponse.prototype._onHeaders = function _onHeaders(headers) {\n  // * A single \":status\" header field is defined that carries the HTTP status code field. This\n  //   header field MUST be included in all responses.\n  // * A client MUST treat the absence of the \":status\" header field, the presence of multiple\n  //   values, or an invalid value as a stream error of type PROTOCOL_ERROR.\n  //   Note: currently, we do not enforce it strictly: we accept any format, and parse it as int\n  // * HTTP/2.0 does not define a way to carry the reason phrase that is included in an HTTP/1.1\n  //   status line.\n  this.statusCode = parseInt(this._checkSpecialHeader(':status', headers[':status']));\n\n  // * Handling regular headers.\n  IncomingMessage.prototype._onHeaders.call(this, headers);\n\n  // * Signaling that the headers arrived.\n  this._log.info({ status: this.statusCode, headers: this.headers}, 'Incoming response');\n  this.emit('ready');\n};\n\n// IncomingPromise class\n// -------------------------\n\nfunction IncomingPromise(responseStream, promiseHeaders) {\n  var stream = new Readable();\n  stream._read = noop;\n  stream.push(null);\n  stream._log = responseStream._log;\n\n  IncomingRequest.call(this, stream);\n\n  this._onHeaders(promiseHeaders);\n\n  this._responseStream = responseStream;\n\n  var response = new IncomingResponse(this._responseStream);\n  response.once('ready', this.emit.bind(this, 'response', response));\n\n  this.stream.on('promise', this._onPromise.bind(this));\n}\nIncomingPromise.prototype = Object.create(IncomingRequest.prototype, { constructor: { value: IncomingPromise } });\n\nIncomingPromise.prototype.cancel = function cancel() {\n  this._responseStream.reset('CANCEL');\n};\n\nIncomingPromise.prototype.setPriority = function setPriority(priority) {\n  this._responseStream.priority(priority);\n};\n\nIncomingPromise.prototype._onPromise = OutgoingRequest.prototype._onPromise;\n","/home/travis/build/npmtest/node-npmtest-http2/node_modules/http2/lib/protocol/index.js":"// This is an implementation of the [HTTP/2][http2]\n// framing layer for [node.js][node].\n//\n// The main building blocks are [node.js streams][node-stream] that are connected through pipes.\n//\n// The main components are:\n//\n// * [Endpoint](endpoint.html): represents an HTTP/2 endpoint (client or server). It's\n//   responsible for the the first part of the handshake process (sending/receiving the\n//   [connection header][http2-connheader]) and manages other components (framer, compressor,\n//   connection, streams) that make up a client or server.\n//\n// * [Connection](connection.html): multiplexes the active HTTP/2 streams, manages connection\n//   lifecycle and settings, and responsible for enforcing the connection level limits (flow\n//   control, initiated stream limit)\n//\n// * [Stream](stream.html): implementation of the [HTTP/2 stream concept][http2-stream].\n//   Implements the [stream state machine][http2-streamstate] defined by the standard, provides\n//   management methods and events for using the stream (sending/receiving headers, data, etc.),\n//   and enforces stream level constraints (flow control, sending only legal frames).\n//\n// * [Flow](flow.html): implements flow control for Connection and Stream as parent class.\n//\n// * [Compressor and Decompressor](compressor.html): compression and decompression of HEADER and\n//   PUSH_PROMISE frames\n//\n// * [Serializer and Deserializer](framer.html): the lowest layer in the stack that transforms\n//   between the binary and the JavaScript object representation of HTTP/2 frames\n//\n// [http2]:               https://tools.ietf.org/html/rfc7540\n// [http2-connheader]:    https://tools.ietf.org/html/rfc7540#section-3.5\n// [http2-stream]:        https://tools.ietf.org/html/rfc7540#section-5\n// [http2-streamstate]:   https://tools.ietf.org/html/rfc7540#section-5.1\n// [node]:                https://nodejs.org/\n// [node-stream]:         https://nodejs.org/api/stream.html\n// [node-https]:          https://nodejs.org/api/https.html\n// [node-http]:           https://nodejs.org/api/http.html\n\nexports.VERSION = 'h2';\n\nexports.Endpoint = require('./endpoint').Endpoint;\n\n/* Bunyan serializers exported by submodules that are worth adding when creating a logger. */\nexports.serializers = {};\nvar modules = ['./framer', './compressor', './flow', './connection', './stream', './endpoint'];\nmodules.map(require).forEach(function(module) {\n  for (var name in module.serializers) {\n    exports.serializers[name] = module.serializers[name];\n  }\n});\n\n/*\n              Stream API            Endpoint API\n              Stream data\n\n             |            ^        |            ^\n             |            |        |            |\n             |            |        |            |\n +-----------|------------|---------------------------------------+\n |           |            |   Endpoint                            |\n |           |            |                                       |\n |   +-------|------------|-----------------------------------+   |\n |   |       |            |  Connection                       |   |\n |   |       v            |                                   |   |\n |   |  +-----------------------+  +--------------------      |   |\n |   |  |        Stream         |  |         Stream      ...  |   |\n |   |  +-----------------------+  +--------------------      |   |\n |   |       |            ^              |            ^       |   |\n |   |       v            |              v            |       |   |\n |   |       +------------+--+--------+--+------------+- ...  |   |\n |   |                       |        ^                       |   |\n |   |                       |        |                       |   |\n |   +-----------------------|--------|-----------------------+   |\n |                           |        |                           |\n |                           v        |                           |\n |   +--------------------------+  +--------------------------+   |\n |   |        Compressor        |  |       Decompressor       |   |\n |   +--------------------------+  +--------------------------+   |\n |                           |        ^                           |\n |                           v        |                           |\n |   +--------------------------+  +--------------------------+   |\n |   |        Serializer        |  |       Deserializer       |   |\n |   +--------------------------+  +--------------------------+   |\n |                           |        ^                           |\n +---------------------------|--------|---------------------------+\n                             |        |\n                             v        |\n\n                              Raw data\n\n*/\n","/home/travis/build/npmtest/node-npmtest-http2/node_modules/http2/lib/protocol/endpoint.js":"var assert = require('assert');\n\nvar Serializer   = require('./framer').Serializer;\nvar Deserializer = require('./framer').Deserializer;\nvar Compressor   = require('./compressor').Compressor;\nvar Decompressor = require('./compressor').Decompressor;\nvar Connection   = require('./connection').Connection;\nvar Duplex       = require('stream').Duplex;\nvar Transform    = require('stream').Transform;\n\nexports.Endpoint = Endpoint;\n\n// The Endpoint class\n// ==================\n\n// Public API\n// ----------\n\n// - **new Endpoint(log, role, settings, filters)**: create a new Endpoint.\n//\n//   - `log`: bunyan logger of the parent\n//   - `role`: 'CLIENT' or 'SERVER'\n//   - `settings`: initial HTTP/2 settings\n//   - `filters`: a map of functions that filter the traffic between components (for debugging or\n//     intentional failure injection).\n//\n//     Filter functions get three arguments:\n//     1. `frame`: the current frame\n//     2. `forward(frame)`: function that can be used to forward a frame to the next component\n//     3. `done()`: callback to signal the end of the filter process\n//\n//     Valid filter names and their position in the stack:\n//     - `beforeSerialization`: after compression, before serialization\n//     - `beforeCompression`: after multiplexing, before compression\n//     - `afterDeserialization`: after deserialization, before decompression\n//     - `afterDecompression`: after decompression, before multiplexing\n//\n// * **Event: 'stream' (Stream)**: 'stream' event forwarded from the underlying Connection\n//\n// * **Event: 'error' (type)**: signals an error\n//\n// * **createStream(): Stream**: initiate a new stream (forwarded to the underlying Connection)\n//\n// * **close([error])**: close the connection with an error code\n\n// Constructor\n// -----------\n\n// The process of initialization:\nfunction Endpoint(log, role, settings, filters) {\n  Duplex.call(this);\n\n  // * Initializing logging infrastructure\n  this._log = log.child({ component: 'endpoint', e: this });\n\n  // * First part of the handshake process: sending and receiving the client connection header\n  //   prelude.\n  assert((role === 'CLIENT') || role === 'SERVER');\n  if (role === 'CLIENT') {\n    this._writePrelude();\n  } else {\n    this._readPrelude();\n  }\n\n  // * Initialization of component. This includes the second part of the handshake process:\n  //   sending the first SETTINGS frame. This is done by the connection class right after\n  //   initialization.\n  this._initializeDataFlow(role, settings, filters || {});\n\n  // * Initialization of management code.\n  this._initializeManagement();\n\n  // * Initializing error handling.\n  this._initializeErrorHandling();\n}\nEndpoint.prototype = Object.create(Duplex.prototype, { constructor: { value: Endpoint } });\n\n// Handshake\n// ---------\n\nvar CLIENT_PRELUDE = new Buffer('PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n');\n\n// Writing the client header is simple and synchronous.\nEndpoint.prototype._writePrelude = function _writePrelude() {\n  this._log.debug('Sending the client connection header prelude.');\n  this.push(CLIENT_PRELUDE);\n};\n\n// The asynchronous process of reading the client header:\nEndpoint.prototype._readPrelude = function _readPrelude() {\n  // * progress in the header is tracker using a `cursor`\n  var cursor = 0;\n\n  // * `_write` is temporarily replaced by the comparator function\n  this._write = function _temporalWrite(chunk, encoding, done) {\n    // * which compares the stored header with the current `chunk` byte by byte and emits the\n    //   'error' event if there's a byte that doesn't match\n    var offset = cursor;\n    while(cursor < CLIENT_PRELUDE.length && (cursor - offset) < chunk.length) {\n      if (CLIENT_PRELUDE[cursor] !== chunk[cursor - offset]) {\n        this._log.fatal({ cursor: cursor, offset: offset, chunk: chunk },\n                        'Client connection header prelude does not match.');\n        this._error('handshake', 'PROTOCOL_ERROR');\n        return;\n      }\n      cursor += 1;\n    }\n\n    // * if the whole header is over, and there were no error then restore the original `_write`\n    //   and call it with the remaining part of the current chunk\n    if (cursor === CLIENT_PRELUDE.length) {\n      this._log.debug('Successfully received the client connection header prelude.');\n      delete this._write;\n      chunk = chunk.slice(cursor - offset);\n      this._write(chunk, encoding, done);\n    }\n  };\n};\n\n// Data flow\n// ---------\n\n//     +---------------------------------------------+\n//     |                                             |\n//     |   +-------------------------------------+   |\n//     |   | +---------+ +---------+ +---------+ |   |\n//     |   | | stream1 | | stream2 | |   ...   | |   |\n//     |   | +---------+ +---------+ +---------+ |   |\n//     |   |             connection              |   |\n//     |   +-------------------------------------+   |\n//     |             |                 ^             |\n//     |        pipe |                 | pipe        |\n//     |             v                 |             |\n//     |   +------------------+------------------+   |\n//     |   |    compressor    |   decompressor   |   |\n//     |   +------------------+------------------+   |\n//     |             |                 ^             |\n//     |        pipe |                 | pipe        |\n//     |             v                 |             |\n//     |   +------------------+------------------+   |\n//     |   |    serializer    |   deserializer   |   |\n//     |   +------------------+------------------+   |\n//     |             |                 ^             |\n//     |     _read() |                 | _write()    |\n//     |             v                 |             |\n//     |      +------------+     +-----------+       |\n//     |      |output queue|     |input queue|       |\n//     +------+------------+-----+-----------+-------+\n//                   |                 ^\n//            read() |                 | write()\n//                   v                 |\n\nfunction createTransformStream(filter) {\n  var transform = new Transform({ objectMode: true });\n  var push = transform.push.bind(transform);\n  transform._transform = function(frame, encoding, done) {\n    filter(frame, push, done);\n  };\n  return transform;\n}\n\nfunction pipeAndFilter(stream1, stream2, filter) {\n  if (filter) {\n    stream1.pipe(createTransformStream(filter)).pipe(stream2);\n  } else {\n    stream1.pipe(stream2);\n  }\n}\n\nEndpoint.prototype._initializeDataFlow = function _initializeDataFlow(role, settings, filters) {\n  var firstStreamId, compressorRole, decompressorRole;\n  if (role === 'CLIENT') {\n    firstStreamId = 1;\n    compressorRole = 'REQUEST';\n    decompressorRole = 'RESPONSE';\n  } else {\n    firstStreamId = 2;\n    compressorRole = 'RESPONSE';\n    decompressorRole = 'REQUEST';\n  }\n\n  this._serializer   = new Serializer(this._log);\n  this._deserializer = new Deserializer(this._log);\n  this._compressor   = new Compressor(this._log, compressorRole);\n  this._decompressor = new Decompressor(this._log, decompressorRole);\n  this._connection   = new Connection(this._log, firstStreamId, settings);\n\n  pipeAndFilter(this._connection, this._compressor, filters.beforeCompression);\n  pipeAndFilter(this._compressor, this._serializer, filters.beforeSerialization);\n  pipeAndFilter(this._deserializer, this._decompressor, filters.afterDeserialization);\n  pipeAndFilter(this._decompressor, this._connection, filters.afterDecompression);\n\n  this._connection.on('ACKNOWLEDGED_SETTINGS_HEADER_TABLE_SIZE',\n                      this._decompressor.setTableSizeLimit.bind(this._decompressor));\n  this._connection.on('RECEIVING_SETTINGS_HEADER_TABLE_SIZE',\n                      this._compressor.setTableSizeLimit.bind(this._compressor));\n};\n\nvar noread = {};\nEndpoint.prototype._read = function _read() {\n  this._readableState.sync = true;\n  var moreNeeded = noread, chunk;\n  while (moreNeeded && (chunk = this._serializer.read())) {\n    moreNeeded = this.push(chunk);\n  }\n  if (moreNeeded === noread) {\n    this._serializer.once('readable', this._read.bind(this));\n  }\n  this._readableState.sync = false;\n};\n\nEndpoint.prototype._write = function _write(chunk, encoding, done) {\n  this._deserializer.write(chunk, encoding, done);\n};\n\n// Management\n// --------------\n\nEndpoint.prototype._initializeManagement = function _initializeManagement() {\n  this._connection.on('stream', this.emit.bind(this, 'stream'));\n};\n\nEndpoint.prototype.createStream = function createStream() {\n  return this._connection.createStream();\n};\n\n// Error handling\n// --------------\n\nEndpoint.prototype._initializeErrorHandling = function _initializeErrorHandling() {\n  this._serializer.on('error', this._error.bind(this, 'serializer'));\n  this._deserializer.on('error', this._error.bind(this, 'deserializer'));\n  this._compressor.on('error', this._error.bind(this, 'compressor'));\n  this._decompressor.on('error', this._error.bind(this, 'decompressor'));\n  this._connection.on('error', this._error.bind(this, 'connection'));\n\n  this._connection.on('peerError', this.emit.bind(this, 'peerError'));\n};\n\nEndpoint.prototype._error = function _error(component, error) {\n  this._log.fatal({ source: component, message: error }, 'Fatal error, closing connection');\n  this.close(error);\n  setImmediate(this.emit.bind(this, 'error', error));\n};\n\nEndpoint.prototype.close = function close(error) {\n  this._connection.close(error);\n};\n\n// Bunyan serializers\n// ------------------\n\nexports.serializers = {};\n\nvar nextId = 0;\nexports.serializers.e = function(endpoint) {\n  if (!('id' in endpoint)) {\n    endpoint.id = nextId;\n    nextId += 1;\n  }\n  return endpoint.id;\n};\n","/home/travis/build/npmtest/node-npmtest-http2/node_modules/http2/lib/protocol/framer.js":"// The framer consists of two [Transform Stream][1] subclasses that operate in [object mode][2]:\n// the Serializer and the Deserializer\n// [1]: https://nodejs.org/api/stream.html#stream_class_stream_transform\n// [2]: https://nodejs.org/api/stream.html#stream_new_stream_readable_options\nvar assert = require('assert');\n\nvar Transform = require('stream').Transform;\n\nexports.Serializer = Serializer;\nexports.Deserializer = Deserializer;\n\nvar logData = Boolean(process.env.HTTP2_LOG_DATA);\n\nvar MAX_PAYLOAD_SIZE = 16384;\nvar WINDOW_UPDATE_PAYLOAD_SIZE = 4;\n\n// Serializer\n// ----------\n//\n//     Frame Objects\n//     * * * * * * * --+---------------------------\n//                     |                          |\n//                     v                          v           Buffers\n//      [] -----> Payload Ser. --[buffers]--> Header Ser. --> * * * *\n//     empty      adds payload                adds header\n//     array        buffers                     buffer\n\nfunction Serializer(log) {\n  this._log = log.child({ component: 'serializer' });\n  Transform.call(this, { objectMode: true });\n}\nSerializer.prototype = Object.create(Transform.prototype, { constructor: { value: Serializer } });\n\n// When there's an incoming frame object, it first generates the frame type specific part of the\n// frame (payload), and then then adds the header part which holds fields that are common to all\n// frame types (like the length of the payload).\nSerializer.prototype._transform = function _transform(frame, encoding, done) {\n  this._log.trace({ frame: frame }, 'Outgoing frame');\n\n  assert(frame.type in Serializer, 'Unknown frame type: ' + frame.type);\n\n  var buffers = [];\n  Serializer[frame.type](frame, buffers);\n  var length = Serializer.commonHeader(frame, buffers);\n\n  assert(length <= MAX_PAYLOAD_SIZE, 'Frame too large!');\n\n  for (var i = 0; i < buffers.length; i++) {\n    if (logData) {\n      this._log.trace({ data: buffers[i] }, 'Outgoing data');\n    }\n    this.push(buffers[i]);\n  }\n\n  done();\n};\n\n// Deserializer\n// ------------\n//\n//     Buffers\n//     * * * * --------+-------------------------\n//                     |                        |\n//                     v                        v           Frame Objects\n//      {} -----> Header Des. --{frame}--> Payload Des. --> * * * * * * *\n//     empty      adds parsed              adds parsed\n//     object  header properties        payload properties\n\nfunction Deserializer(log, role) {\n  this._role = role;\n  this._log = log.child({ component: 'deserializer' });\n  Transform.call(this, { objectMode: true });\n  this._next(COMMON_HEADER_SIZE);\n}\nDeserializer.prototype = Object.create(Transform.prototype, { constructor: { value: Deserializer } });\n\n// The Deserializer is stateful, and it's two main alternating states are: *waiting for header* and\n// *waiting for payload*. The state is stored in the boolean property `_waitingForHeader`.\n//\n// When entering a new state, a `_buffer` is created that will hold the accumulated data (header or\n// payload). The `_cursor` is used to track the progress.\nDeserializer.prototype._next = function(size) {\n  this._cursor = 0;\n  this._buffer = new Buffer(size);\n  this._waitingForHeader = !this._waitingForHeader;\n  if (this._waitingForHeader) {\n    this._frame = {};\n  }\n};\n\n// Parsing an incoming buffer is an iterative process because it can hold multiple frames if it's\n// large enough. A `cursor` is used to track the progress in parsing the incoming `chunk`.\nDeserializer.prototype._transform = function _transform(chunk, encoding, done) {\n  var cursor = 0;\n\n  if (logData) {\n    this._log.trace({ data: chunk }, 'Incoming data');\n  }\n\n  while(cursor < chunk.length) {\n    // The content of an incoming buffer is first copied to `_buffer`. If it can't hold the full\n    // chunk, then only a part of it is copied.\n    var toCopy = Math.min(chunk.length - cursor, this._buffer.length - this._cursor);\n    chunk.copy(this._buffer, this._cursor, cursor, cursor + toCopy);\n    this._cursor += toCopy;\n    cursor += toCopy;\n\n    // When `_buffer` is full, it's content gets parsed either as header or payload depending on\n    // the actual state.\n\n    // If it's header then the parsed data is stored in a temporary variable and then the\n    // deserializer waits for the specified length payload.\n    if ((this._cursor === this._buffer.length) && this._waitingForHeader) {\n      var payloadSize = Deserializer.commonHeader(this._buffer, this._frame);\n      if (payloadSize <= MAX_PAYLOAD_SIZE) {\n        this._next(payloadSize);\n      } else {\n        this.emit('error', 'FRAME_SIZE_ERROR');\n        return;\n      }\n    }\n\n    // If it's payload then the the frame object is finalized and then gets pushed out.\n    // Unknown frame types are ignored.\n    //\n    // Note: If we just finished the parsing of a header and the payload length is 0, this branch\n    // will also run.\n    if ((this._cursor === this._buffer.length) && !this._waitingForHeader) {\n      if (this._frame.type) {\n        var error = Deserializer[this._frame.type](this._buffer, this._frame, this._role);\n        if (error) {\n          this._log.error('Incoming frame parsing error: ' + error);\n          this.emit('error', error);\n        } else {\n          this._log.trace({ frame: this._frame }, 'Incoming frame');\n          this.push(this._frame);\n        }\n      } else {\n        this._log.error('Unknown type incoming frame');\n        // Ignore it other than logging\n      }\n      this._next(COMMON_HEADER_SIZE);\n    }\n  }\n\n  done();\n};\n\n// [Frame Header](https://tools.ietf.org/html/rfc7540#section-4.1)\n// --------------------------------------------------------------\n//\n// HTTP/2 frames share a common base format consisting of a 9-byte header followed by 0 to 2^24 - 1\n// bytes of data.\n//\n// Additional size limits can be set by specific application uses. HTTP limits the frame size to\n// 16,384 octets by default, though this can be increased by a receiver.\n//\n//      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |                 Length (24)                   |\n//     +---------------+---------------+---------------+\n//     |   Type (8)    |   Flags (8)   |\n//     +-+-----------------------------+---------------+---------------+\n//     |R|                 Stream Identifier (31)                      |\n//     +-+-------------------------------------------------------------+\n//     |                     Frame Data (0...)                       ...\n//     +---------------------------------------------------------------+\n//\n// The fields of the frame header are defined as:\n//\n// * Length:\n//   The length of the frame data expressed as an unsigned 24-bit integer. The 9 bytes of the frame\n//   header are not included in this value.\n//\n// * Type:\n//   The 8-bit type of the frame. The frame type determines how the remainder of the frame header\n//   and data are interpreted. Implementations MUST ignore unsupported and unrecognized frame types.\n//\n// * Flags:\n//   An 8-bit field reserved for frame-type specific boolean flags.\n//\n//   Flags are assigned semantics specific to the indicated frame type. Flags that have no defined\n//   semantics for a particular frame type MUST be ignored, and MUST be left unset (0) when sending.\n//\n// * R:\n//   A reserved 1-bit field. The semantics of this bit are undefined and the bit MUST remain unset\n//   (0) when sending and MUST be ignored when receiving.\n//\n// * Stream Identifier:\n//   A 31-bit stream identifier. The value 0 is reserved for frames that are associated with the\n//   connection as a whole as opposed to an individual stream.\n//\n// The structure and content of the remaining frame data is dependent entirely on the frame type.\n\nvar COMMON_HEADER_SIZE = 9;\n\nvar frameTypes = [];\n\nvar frameFlags = {};\n\nvar genericAttributes = ['type', 'flags', 'stream'];\n\nvar typeSpecificAttributes = {};\n\nSerializer.commonHeader = function writeCommonHeader(frame, buffers) {\n  var headerBuffer = new Buffer(COMMON_HEADER_SIZE);\n\n  var size = 0;\n  for (var i = 0; i < buffers.length; i++) {\n    size += buffers[i].length;\n  }\n  headerBuffer.writeUInt8(0, 0);\n  headerBuffer.writeUInt16BE(size, 1);\n\n  var typeId = frameTypes.indexOf(frame.type);  // If we are here then the type is valid for sure\n  headerBuffer.writeUInt8(typeId, 3);\n\n  var flagByte = 0;\n  for (var flag in frame.flags) {\n    var position = frameFlags[frame.type].indexOf(flag);\n    assert(position !== -1, 'Unknown flag for frame type ' + frame.type + ': ' + flag);\n    if (frame.flags[flag]) {\n      flagByte |= (1 << position);\n    }\n  }\n  headerBuffer.writeUInt8(flagByte, 4);\n\n  assert((0 <= frame.stream) && (frame.stream < 0x7fffffff), frame.stream);\n  headerBuffer.writeUInt32BE(frame.stream || 0, 5);\n\n  buffers.unshift(headerBuffer);\n\n  return size;\n};\n\nDeserializer.commonHeader = function readCommonHeader(buffer, frame) {\n  if (buffer.length < 9) {\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  var totallyWastedByte = buffer.readUInt8(0);\n  var length = buffer.readUInt16BE(1);\n  // We do this just for sanity checking later on, to make sure no one sent us a\n  // frame that's super large.\n  length += totallyWastedByte << 16;\n\n  frame.type = frameTypes[buffer.readUInt8(3)];\n  if (!frame.type) {\n    // We are required to ignore unknown frame types\n    return length;\n  }\n\n  frame.flags = {};\n  var flagByte = buffer.readUInt8(4);\n  var definedFlags = frameFlags[frame.type];\n  for (var i = 0; i < definedFlags.length; i++) {\n    frame.flags[definedFlags[i]] = Boolean(flagByte & (1 << i));\n  }\n\n  frame.stream = buffer.readUInt32BE(5) & 0x7fffffff;\n\n  return length;\n};\n\n// Frame types\n// ===========\n\n// Every frame type is registered in the following places:\n//\n// * `frameTypes`: a register of frame type codes (used by `commonHeader()`)\n// * `frameFlags`: a register of valid flags for frame types (used by `commonHeader()`)\n// * `typeSpecificAttributes`: a register of frame specific frame object attributes (used by\n//   logging code and also serves as documentation for frame objects)\n\n// [DATA Frames](https://tools.ietf.org/html/rfc7540#section-6.1)\n// ------------------------------------------------------------\n//\n// DATA frames (type=0x0) convey arbitrary, variable-length sequences of octets associated with a\n// stream.\n//\n// The DATA frame defines the following flags:\n//\n// * END_STREAM (0x1):\n//   Bit 1 being set indicates that this frame is the last that the endpoint will send for the\n//   identified stream.\n// * PADDED (0x08):\n//   Bit 4 being set indicates that the Pad Length field is present.\n\nframeTypes[0x0] = 'DATA';\n\nframeFlags.DATA = ['END_STREAM', 'RESERVED2', 'RESERVED4', 'PADDED'];\n\ntypeSpecificAttributes.DATA = ['data'];\n\nSerializer.DATA = function writeData(frame, buffers) {\n  buffers.push(frame.data);\n};\n\nDeserializer.DATA = function readData(buffer, frame) {\n  var dataOffset = 0;\n  var paddingLength = 0;\n  if (frame.flags.PADDED) {\n    if (buffer.length < 1) {\n      // We must have at least one byte for padding control, but we don't. Bad peer!\n      return 'FRAME_SIZE_ERROR';\n    }\n    paddingLength = (buffer.readUInt8(dataOffset) & 0xff);\n    dataOffset = 1;\n  }\n\n  if (paddingLength) {\n    if (paddingLength >= (buffer.length - 1)) {\n      // We don't have enough room for the padding advertised - bad peer!\n      return 'FRAME_SIZE_ERROR';\n    }\n    frame.data = buffer.slice(dataOffset, -1 * paddingLength);\n  } else {\n    frame.data = buffer.slice(dataOffset);\n  }\n};\n\n// [HEADERS](https://tools.ietf.org/html/rfc7540#section-6.2)\n// --------------------------------------------------------------\n//\n// The HEADERS frame (type=0x1) allows the sender to create a stream.\n//\n// The HEADERS frame defines the following flags:\n//\n// * END_STREAM (0x1):\n//   Bit 1 being set indicates that this frame is the last that the endpoint will send for the\n//   identified stream.\n// * END_HEADERS (0x4):\n//   The END_HEADERS bit indicates that this frame contains the entire payload necessary to provide\n//   a complete set of headers.\n// * PADDED (0x08):\n//   Bit 4 being set indicates that the Pad Length field is present.\n// * PRIORITY (0x20):\n//   Bit 6 being set indicates that the Exlusive Flag (E), Stream Dependency, and Weight fields are\n//   present.\n\nframeTypes[0x1] = 'HEADERS';\n\nframeFlags.HEADERS = ['END_STREAM', 'RESERVED2', 'END_HEADERS', 'PADDED', 'RESERVED5', 'PRIORITY'];\n\ntypeSpecificAttributes.HEADERS = ['priorityDependency', 'priorityWeight', 'exclusiveDependency', 'headers', 'data'];\n\n//      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |Pad Length? (8)|\n//     +-+-------------+---------------+-------------------------------+\n//     |E|                 Stream Dependency? (31)                     |\n//     +-+-------------+-----------------------------------------------+\n//     |  Weight? (8)  |\n//     +-+-------------+-----------------------------------------------+\n//     |                   Header Block Fragment (*)                 ...\n//     +---------------------------------------------------------------+\n//     |                           Padding (*)                       ...\n//     +---------------------------------------------------------------+\n//\n// The payload of a HEADERS frame contains a Headers Block\n\nSerializer.HEADERS = function writeHeadersPriority(frame, buffers) {\n  if (frame.flags.PRIORITY) {\n    var buffer = new Buffer(5);\n    assert((0 <= frame.priorityDependency) && (frame.priorityDependency <= 0x7fffffff), frame.priorityDependency);\n    buffer.writeUInt32BE(frame.priorityDependency, 0);\n    if (frame.exclusiveDependency) {\n      buffer[0] |= 0x80;\n    }\n    assert((0 <= frame.priorityWeight) && (frame.priorityWeight <= 0xff), frame.priorityWeight);\n    buffer.writeUInt8(frame.priorityWeight, 4);\n    buffers.push(buffer);\n  }\n  buffers.push(frame.data);\n};\n\nDeserializer.HEADERS = function readHeadersPriority(buffer, frame) {\n  var minFrameLength = 0;\n  if (frame.flags.PADDED) {\n    minFrameLength += 1;\n  }\n  if (frame.flags.PRIORITY) {\n    minFrameLength += 5;\n  }\n  if (buffer.length < minFrameLength) {\n    // Peer didn't send enough data - bad peer!\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  var dataOffset = 0;\n  var paddingLength = 0;\n  if (frame.flags.PADDED) {\n    paddingLength = (buffer.readUInt8(dataOffset) & 0xff);\n    dataOffset = 1;\n  }\n\n  if (frame.flags.PRIORITY) {\n    var dependencyData = new Buffer(4);\n    buffer.copy(dependencyData, 0, dataOffset, dataOffset + 4);\n    dataOffset += 4;\n    frame.exclusiveDependency = !!(dependencyData[0] & 0x80);\n    dependencyData[0] &= 0x7f;\n    frame.priorityDependency = dependencyData.readUInt32BE(0);\n    frame.priorityWeight = buffer.readUInt8(dataOffset);\n    dataOffset += 1;\n  }\n\n  if (paddingLength) {\n    if ((buffer.length - dataOffset) < paddingLength) {\n      // Not enough data left to satisfy the advertised padding - bad peer!\n      return 'FRAME_SIZE_ERROR';\n    }\n    frame.data = buffer.slice(dataOffset, -1 * paddingLength);\n  } else {\n    frame.data = buffer.slice(dataOffset);\n  }\n};\n\n// [PRIORITY](https://tools.ietf.org/html/rfc7540#section-6.3)\n// -------------------------------------------------------\n//\n// The PRIORITY frame (type=0x2) specifies the sender-advised priority of a stream.\n//\n// The PRIORITY frame does not define any flags.\n\nframeTypes[0x2] = 'PRIORITY';\n\nframeFlags.PRIORITY = [];\n\ntypeSpecificAttributes.PRIORITY = ['priorityDependency', 'priorityWeight', 'exclusiveDependency'];\n\n//      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |E|                 Stream Dependency? (31)                     |\n//     +-+-------------+-----------------------------------------------+\n//     |  Weight? (8)  |\n//     +-+-------------+\n//\n// The payload of a PRIORITY frame contains an exclusive bit, a 31-bit dependency, and an 8-bit weight\n\nSerializer.PRIORITY = function writePriority(frame, buffers) {\n  var buffer = new Buffer(5);\n  assert((0 <= frame.priorityDependency) && (frame.priorityDependency <= 0x7fffffff), frame.priorityDependency);\n  buffer.writeUInt32BE(frame.priorityDependency, 0);\n  if (frame.exclusiveDependency) {\n    buffer[0] |= 0x80;\n  }\n  assert((0 <= frame.priorityWeight) && (frame.priorityWeight <= 0xff), frame.priorityWeight);\n  buffer.writeUInt8(frame.priorityWeight, 4);\n\n  buffers.push(buffer);\n};\n\nDeserializer.PRIORITY = function readPriority(buffer, frame) {\n  if (buffer.length < 5) {\n    // PRIORITY frames are 5 bytes long. Bad peer!\n    return 'FRAME_SIZE_ERROR';\n  }\n  var dependencyData = new Buffer(4);\n  buffer.copy(dependencyData, 0, 0, 4);\n  frame.exclusiveDependency = !!(dependencyData[0] & 0x80);\n  dependencyData[0] &= 0x7f;\n  frame.priorityDependency = dependencyData.readUInt32BE(0);\n  frame.priorityWeight = buffer.readUInt8(4);\n};\n\n// [RST_STREAM](https://tools.ietf.org/html/rfc7540#section-6.4)\n// -----------------------------------------------------------\n//\n// The RST_STREAM frame (type=0x3) allows for abnormal termination of a stream.\n//\n// No type-flags are defined.\n\nframeTypes[0x3] = 'RST_STREAM';\n\nframeFlags.RST_STREAM = [];\n\ntypeSpecificAttributes.RST_STREAM = ['error'];\n\n//      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |                         Error Code (32)                       |\n//     +---------------------------------------------------------------+\n//\n// The RST_STREAM frame contains a single unsigned, 32-bit integer identifying the error\n// code (see Error Codes). The error code indicates why the stream is being terminated.\n\nSerializer.RST_STREAM = function writeRstStream(frame, buffers) {\n  var buffer = new Buffer(4);\n  var code = errorCodes.indexOf(frame.error);\n  assert((0 <= code) && (code <= 0xffffffff), code);\n  buffer.writeUInt32BE(code, 0);\n  buffers.push(buffer);\n};\n\nDeserializer.RST_STREAM = function readRstStream(buffer, frame) {\n  if (buffer.length < 4) {\n    // RST_STREAM is 4 bytes long. Bad peer!\n    return 'FRAME_SIZE_ERROR';\n  }\n  frame.error = errorCodes[buffer.readUInt32BE(0)];\n  if (!frame.error) {\n    // Unknown error codes are considered equivalent to INTERNAL_ERROR\n    frame.error = 'INTERNAL_ERROR';\n  }\n};\n\n// [SETTINGS](https://tools.ietf.org/html/rfc7540#section-6.5)\n// -------------------------------------------------------\n//\n// The SETTINGS frame (type=0x4) conveys configuration parameters that affect how endpoints\n// communicate.\n//\n// The SETTINGS frame defines the following flag:\n\n// * ACK (0x1):\n//   Bit 1 being set indicates that this frame acknowledges receipt and application of the peer's\n//   SETTINGS frame.\nframeTypes[0x4] = 'SETTINGS';\n\nframeFlags.SETTINGS = ['ACK'];\n\ntypeSpecificAttributes.SETTINGS = ['settings'];\n\n// The payload of a SETTINGS frame consists of zero or more settings. Each setting consists of a\n// 16-bit identifier, and an unsigned 32-bit value.\n//\n//      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |         Identifier(16)          |        Value (32)           |\n//     +-----------------+---------------------------------------------+\n//     ...Value                          |\n//     +---------------------------------+\n//\n// Each setting in a SETTINGS frame replaces the existing value for that setting.  Settings are\n// processed in the order in which they appear, and a receiver of a SETTINGS frame does not need to\n// maintain any state other than the current value of settings.  Therefore, the value of a setting\n// is the last value that is seen by a receiver. This permits the inclusion of the same settings\n// multiple times in the same SETTINGS frame, though doing so does nothing other than waste\n// connection capacity.\n\nSerializer.SETTINGS = function writeSettings(frame, buffers) {\n  var settings = [], settingsLeft = Object.keys(frame.settings);\n  definedSettings.forEach(function(setting, id) {\n    if (setting.name in frame.settings) {\n      settingsLeft.splice(settingsLeft.indexOf(setting.name), 1);\n      var value = frame.settings[setting.name];\n      settings.push({ id: id, value: setting.flag ? Boolean(value) : value });\n    }\n  });\n  assert(settingsLeft.length === 0, 'Unknown settings: ' + settingsLeft.join(', '));\n\n  var buffer = new Buffer(settings.length * 6);\n  for (var i = 0; i < settings.length; i++) {\n    buffer.writeUInt16BE(settings[i].id & 0xffff, i*6);\n    buffer.writeUInt32BE(settings[i].value, i*6 + 2);\n  }\n\n  buffers.push(buffer);\n};\n\nDeserializer.SETTINGS = function readSettings(buffer, frame, role) {\n  frame.settings = {};\n\n  // Receipt of a SETTINGS frame with the ACK flag set and a length\n  // field value other than 0 MUST be treated as a connection error\n  // (Section 5.4.1) of type FRAME_SIZE_ERROR.\n  if(frame.flags.ACK && buffer.length != 0) {\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  if (buffer.length % 6 !== 0) {\n    return 'PROTOCOL_ERROR';\n  }\n  for (var i = 0; i < buffer.length / 6; i++) {\n    var id = buffer.readUInt16BE(i*6) & 0xffff;\n    var setting = definedSettings[id];\n    if (setting) {\n      if (role == 'CLIENT' && setting.name == 'SETTINGS_ENABLE_PUSH') {\n        return 'SETTINGS frame on client got SETTINGS_ENABLE_PUSH';\n      }\n      var value = buffer.readUInt32BE(i*6 + 2);\n      frame.settings[setting.name] = setting.flag ? Boolean(value & 0x1) : value;\n    }\n  }\n};\n\n// The following settings are defined:\nvar definedSettings = [];\n\n// * SETTINGS_HEADER_TABLE_SIZE (1):\n//   Allows the sender to inform the remote endpoint of the size of the header compression table\n//   used to decode header blocks.\ndefinedSettings[1] = { name: 'SETTINGS_HEADER_TABLE_SIZE', flag: false };\n\n// * SETTINGS_ENABLE_PUSH (2):\n//   This setting can be use to disable server push. An endpoint MUST NOT send a PUSH_PROMISE frame\n//   if it receives this setting set to a value of 0. The default value is 1, which indicates that\n//   push is permitted.\ndefinedSettings[2] = { name: 'SETTINGS_ENABLE_PUSH', flag: true };\n\n// * SETTINGS_MAX_CONCURRENT_STREAMS (3):\n//   indicates the maximum number of concurrent streams that the sender will allow.\ndefinedSettings[3] = { name: 'SETTINGS_MAX_CONCURRENT_STREAMS', flag: false };\n\n// * SETTINGS_INITIAL_WINDOW_SIZE (4):\n//   indicates the sender's initial stream window size (in bytes) for new streams.\ndefinedSettings[4] = { name: 'SETTINGS_INITIAL_WINDOW_SIZE', flag: false };\n\n// * SETTINGS_MAX_FRAME_SIZE (5):\n//   indicates the maximum size of a frame the receiver will allow.\ndefinedSettings[5] = { name: 'SETTINGS_MAX_FRAME_SIZE', flag: false };\n\n// [PUSH_PROMISE](https://tools.ietf.org/html/rfc7540#section-6.6)\n// ---------------------------------------------------------------\n//\n// The PUSH_PROMISE frame (type=0x5) is used to notify the peer endpoint in advance of streams the\n// sender intends to initiate.\n//\n// The PUSH_PROMISE frame defines the following flags:\n//\n// * END_PUSH_PROMISE (0x4):\n//   The END_PUSH_PROMISE bit indicates that this frame contains the entire payload necessary to\n//   provide a complete set of headers.\n\nframeTypes[0x5] = 'PUSH_PROMISE';\n\nframeFlags.PUSH_PROMISE = ['RESERVED1', 'RESERVED2', 'END_PUSH_PROMISE', 'PADDED'];\n\ntypeSpecificAttributes.PUSH_PROMISE = ['promised_stream', 'headers', 'data'];\n\n//      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |Pad Length? (8)|\n//     +-+-------------+-----------------------------------------------+\n//     |X|                Promised-Stream-ID (31)                      |\n//     +-+-------------------------------------------------------------+\n//     |                 Header Block Fragment (*)                   ...\n//     +---------------------------------------------------------------+\n//     |                         Padding (*)                         ...\n//     +---------------------------------------------------------------+\n//\n// The PUSH_PROMISE frame includes the unsigned 31-bit identifier of\n// the stream the endpoint plans to create along with a minimal set of headers that provide\n// additional context for the stream.\n\nSerializer.PUSH_PROMISE = function writePushPromise(frame, buffers) {\n  var buffer = new Buffer(4);\n\n  var promised_stream = frame.promised_stream;\n  assert((0 <= promised_stream) && (promised_stream <= 0x7fffffff), promised_stream);\n  buffer.writeUInt32BE(promised_stream, 0);\n\n  buffers.push(buffer);\n  buffers.push(frame.data);\n};\n\nDeserializer.PUSH_PROMISE = function readPushPromise(buffer, frame) {\n  if (buffer.length < 4) {\n    return 'FRAME_SIZE_ERROR';\n  }\n  var dataOffset = 0;\n  var paddingLength = 0;\n  if (frame.flags.PADDED) {\n    if (buffer.length < 5) {\n      return 'FRAME_SIZE_ERROR';\n    }\n    paddingLength = (buffer.readUInt8(dataOffset) & 0xff);\n    dataOffset = 1;\n  }\n  frame.promised_stream = buffer.readUInt32BE(dataOffset) & 0x7fffffff;\n  dataOffset += 4;\n  if (paddingLength) {\n    if ((buffer.length - dataOffset) < paddingLength) {\n      return 'FRAME_SIZE_ERROR';\n    }\n    frame.data = buffer.slice(dataOffset, -1 * paddingLength);\n  } else {\n    frame.data = buffer.slice(dataOffset);\n  }\n};\n\n// [PING](https://tools.ietf.org/html/rfc7540#section-6.7)\n// -----------------------------------------------\n//\n// The PING frame (type=0x6) is a mechanism for measuring a minimal round-trip time from the\n// sender, as well as determining whether an idle connection is still functional.\n//\n// The PING frame defines one type-specific flag:\n//\n// * ACK (0x1):\n//   Bit 1 being set indicates that this PING frame is a PING response.\n\nframeTypes[0x6] = 'PING';\n\nframeFlags.PING = ['ACK'];\n\ntypeSpecificAttributes.PING = ['data'];\n\n// In addition to the frame header, PING frames MUST contain 8 additional octets of opaque data.\n\nSerializer.PING = function writePing(frame, buffers) {\n  buffers.push(frame.data);\n};\n\nDeserializer.PING = function readPing(buffer, frame) {\n  if (buffer.length !== 8) {\n    return 'FRAME_SIZE_ERROR';\n  }\n  frame.data = buffer;\n};\n\n// [GOAWAY](https://tools.ietf.org/html/rfc7540#section-6.8)\n// ---------------------------------------------------\n//\n// The GOAWAY frame (type=0x7) informs the remote peer to stop creating streams on this connection.\n//\n// The GOAWAY frame does not define any flags.\n\nframeTypes[0x7] = 'GOAWAY';\n\nframeFlags.GOAWAY = [];\n\ntypeSpecificAttributes.GOAWAY = ['last_stream', 'error'];\n\n//      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |X|                  Last-Stream-ID (31)                        |\n//     +-+-------------------------------------------------------------+\n//     |                      Error Code (32)                          |\n//     +---------------------------------------------------------------+\n//\n// The last stream identifier in the GOAWAY frame contains the highest numbered stream identifier\n// for which the sender of the GOAWAY frame has received frames on and might have taken some action\n// on.\n//\n// The GOAWAY frame also contains a 32-bit error code (see Error Codes) that contains the reason for\n// closing the connection.\n\nSerializer.GOAWAY = function writeGoaway(frame, buffers) {\n  var buffer = new Buffer(8);\n\n  var last_stream = frame.last_stream;\n  assert((0 <= last_stream) && (last_stream <= 0x7fffffff), last_stream);\n  buffer.writeUInt32BE(last_stream, 0);\n\n  var code = errorCodes.indexOf(frame.error);\n  assert((0 <= code) && (code <= 0xffffffff), code);\n  buffer.writeUInt32BE(code, 4);\n\n  buffers.push(buffer);\n};\n\nDeserializer.GOAWAY = function readGoaway(buffer, frame) {\n  if (buffer.length !== 8) {\n    // GOAWAY must have 8 bytes\n    return 'FRAME_SIZE_ERROR';\n  }\n  frame.last_stream = buffer.readUInt32BE(0) & 0x7fffffff;\n  frame.error = errorCodes[buffer.readUInt32BE(4)];\n  if (!frame.error) {\n    // Unknown error types are to be considered equivalent to INTERNAL ERROR\n    frame.error = 'INTERNAL_ERROR';\n  }\n};\n\n// [WINDOW_UPDATE](https://tools.ietf.org/html/rfc7540#section-6.9)\n// -----------------------------------------------------------------\n//\n// The WINDOW_UPDATE frame (type=0x8) is used to implement flow control.\n//\n// The WINDOW_UPDATE frame does not define any flags.\n\nframeTypes[0x8] = 'WINDOW_UPDATE';\n\nframeFlags.WINDOW_UPDATE = [];\n\ntypeSpecificAttributes.WINDOW_UPDATE = ['window_size'];\n\n// The payload of a WINDOW_UPDATE frame is a 32-bit value indicating the additional number of bytes\n// that the sender can transmit in addition to the existing flow control window. The legal range\n// for this field is 1 to 2^31 - 1 (0x7fffffff) bytes; the most significant bit of this value is\n// reserved.\n\nSerializer.WINDOW_UPDATE = function writeWindowUpdate(frame, buffers) {\n  var buffer = new Buffer(4);\n\n  var window_size = frame.window_size;\n  assert((0 < window_size) && (window_size <= 0x7fffffff), window_size);\n  buffer.writeUInt32BE(window_size, 0);\n\n  buffers.push(buffer);\n};\n\nDeserializer.WINDOW_UPDATE = function readWindowUpdate(buffer, frame) {\n  if (buffer.length !== WINDOW_UPDATE_PAYLOAD_SIZE) {\n    return 'FRAME_SIZE_ERROR';\n  }\n  frame.window_size = buffer.readUInt32BE(0) & 0x7fffffff;\n  if (frame.window_size === 0) {\n    return 'PROTOCOL_ERROR';\n  }\n};\n\n// [CONTINUATION](https://tools.ietf.org/html/rfc7540#section-6.10)\n// ------------------------------------------------------------\n//\n// The CONTINUATION frame (type=0x9) is used to continue a sequence of header block fragments.\n//\n// The CONTINUATION frame defines the following flag:\n//\n// * END_HEADERS (0x4):\n//   The END_HEADERS bit indicates that this frame ends the sequence of header block fragments\n//   necessary to provide a complete set of headers.\n\nframeTypes[0x9] = 'CONTINUATION';\n\nframeFlags.CONTINUATION = ['RESERVED1', 'RESERVED2', 'END_HEADERS'];\n\ntypeSpecificAttributes.CONTINUATION = ['headers', 'data'];\n\nSerializer.CONTINUATION = function writeContinuation(frame, buffers) {\n  buffers.push(frame.data);\n};\n\nDeserializer.CONTINUATION = function readContinuation(buffer, frame) {\n  frame.data = buffer;\n};\n\n// [ALTSVC](https://tools.ietf.org/html/rfc7838#section-4)\n// ------------------------------------------------------------\n//\n// The ALTSVC frame (type=0xA) advertises the availability of an alternative service to the client.\n//\n// The ALTSVC frame does not define any flags.\n\nframeTypes[0xA] = 'ALTSVC';\n\nframeFlags.ALTSVC = [];\n\n//     0                   1                   2                   3\n//     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//    |         Origin-Len (16)       | Origin? (*)                 ...\n//    +-------------------------------+----------------+--------------+\n//    |                   Alt-Svc-Field-Value (*)                   ...\n//    +---------------------------------------------------------------+\n//\n// The ALTSVC frame contains the following fields:\n//\n// Origin-Len: An unsigned, 16-bit integer indicating the length, in\n//    octets, of the Origin field.\n//\n// Origin: An OPTIONAL sequence of characters containing ASCII\n//    serialisation of an origin ([RFC6454](https://tools.ietf.org/html/rfc6454),\n//    Section 6.2) that the alternate service is applicable to.\n//\n// Alt-Svc-Field-Value: A sequence of octets (length determined by\n//    subtracting the length of all preceding fields from the frame\n//    length) containing a value identical to the Alt-Svc field value\n//    defined in (Section 3)[https://tools.ietf.org/html/rfc7838#section-3]\n//    (ABNF production \"Alt-Svc\").\n\ntypeSpecificAttributes.ALTSVC = ['maxAge', 'port', 'protocolID', 'host',\n                                 'origin'];\n\nfunction istchar(c) {\n  return ('!#$&\\'*+-.^_`|~1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.indexOf(c) > -1);\n}\n\nfunction hexencode(s) {\n  var t = '';\n  for (var i = 0; i < s.length; i++) {\n    if (!istchar(s[i])) {\n      t += '%';\n      t += new Buffer(s[i]).toString('hex');\n    } else {\n      t += s[i];\n    }\n  }\n  return t;\n}\n\nSerializer.ALTSVC = function writeAltSvc(frame, buffers) {\n  var buffer = new Buffer(2);\n  buffer.writeUInt16BE(frame.origin.length, 0);\n  buffers.push(buffer);\n  buffers.push(new Buffer(frame.origin, 'ascii'));\n\n  var fieldValue = hexencode(frame.protocolID) + '=\"' + frame.host + ':' + frame.port + '\"';\n  if (frame.maxAge !== 86400) { // 86400 is the default\n    fieldValue += \"; ma=\" + frame.maxAge;\n  }\n\n  buffers.push(new Buffer(fieldValue, 'ascii'));\n};\n\nfunction stripquotes(s) {\n  var start = 0;\n  var end = s.length;\n  while ((start < end) && (s[start] === '\"')) {\n    start++;\n  }\n  while ((end > start) && (s[end - 1] === '\"')) {\n    end--;\n  }\n  if (start >= end) {\n    return \"\";\n  }\n  return s.substring(start, end);\n}\n\nfunction splitNameValue(nvpair) {\n  var eq = -1;\n  var inQuotes = false;\n\n  for (var i = 0; i < nvpair.length; i++) {\n    if (nvpair[i] === '\"') {\n      inQuotes = !inQuotes;\n      continue;\n    }\n    if (inQuotes) {\n      continue;\n    }\n    if (nvpair[i] === '=') {\n      eq = i;\n      break;\n    }\n  }\n\n  if (eq === -1) {\n    return {'name': nvpair, 'value': null};\n  }\n\n  var name = stripquotes(nvpair.substring(0, eq).trim());\n  var value = stripquotes(nvpair.substring(eq + 1).trim());\n  return {'name': name, 'value': value};\n}\n\nfunction splitHeaderParameters(hv) {\n  return parseHeaderValue(hv, ';', splitNameValue);\n}\n\nfunction parseHeaderValue(hv, separator, callback) {\n  var start = 0;\n  var inQuotes = false;\n  var values = [];\n\n  for (var i = 0; i < hv.length; i++) {\n    if (hv[i] === '\"') {\n      inQuotes = !inQuotes;\n      continue;\n    }\n    if (inQuotes) {\n      // Just skip this\n      continue;\n    }\n    if (hv[i] === separator) {\n      var newValue = hv.substring(start, i).trim();\n      if (newValue.length > 0) {\n        newValue = callback(newValue);\n        values.push(newValue);\n      }\n      start = i + 1;\n    }\n  }\n\n  var newValue = hv.substring(start).trim();\n  if (newValue.length > 0) {\n    newValue = callback(newValue);\n    values.push(newValue);\n  }\n\n  return values;\n}\n\nfunction rsplit(s, delim, count) {\n  var nsplits = 0;\n  var end = s.length;\n  var rval = [];\n  for (var i = s.length - 1; i >= 0; i--) {\n    if (s[i] === delim) {\n      var t = s.substring(i + 1, end);\n      end = i;\n      rval.unshift(t);\n      nsplits++;\n      if (nsplits === count) {\n        break;\n      }\n    }\n  }\n  if (end !== 0) {\n    rval.unshift(s.substring(0, end));\n  }\n  return rval;\n}\n\nfunction ishex(c) {\n  return ('0123456789ABCDEFabcdef'.indexOf(c) > -1);\n}\n\nfunction unescape(s) {\n  var i = 0;\n  var t = '';\n  while (i < s.length) {\n    if (s[i] != '%' || !ishex(s[i + 1]) || !ishex(s[i + 2])) {\n      t += s[i];\n    } else {\n      ++i;\n      var hexvalue = '';\n      if (i < s.length) {\n        hexvalue += s[i];\n        ++i;\n      }\n      if (i < s.length) {\n        hexvalue += s[i];\n      }\n      if (hexvalue.length > 0) {\n        t += new Buffer(hexvalue, 'hex').toString();\n      } else {\n        t += '%';\n      }\n    }\n\n    ++i;\n  }\n  return t;\n}\n\nDeserializer.ALTSVC = function readAltSvc(buffer, frame) {\n  if (buffer.length < 2) {\n    return 'FRAME_SIZE_ERROR';\n  }\n  var originLength = buffer.readUInt16BE(0);\n  if ((buffer.length - 2) < originLength) {\n    return 'FRAME_SIZE_ERROR';\n  }\n  frame.origin = buffer.toString('ascii', 2, 2 + originLength);\n  var fieldValue = buffer.toString('ascii', 2 + originLength);\n  var values = parseHeaderValue(fieldValue, ',', splitHeaderParameters);\n  if (values.length > 1) {\n    // TODO - warn that we only use one here\n  }\n  if (values.length === 0) {\n    // Well that's a malformed frame. Just ignore it.\n    return;\n  }\n\n  var chosenAltSvc = values[0];\n  frame.maxAge = 86400; // Default\n  for (var i = 0; i < chosenAltSvc.length; i++) {\n    if (i === 0) {\n      // This corresponds to the protocolID=\"<host>:<port>\" item\n      frame.protocolID = unescape(chosenAltSvc[i].name);\n      var hostport = rsplit(chosenAltSvc[i].value, ':', 1);\n      frame.host = hostport[0];\n      frame.port = parseInt(hostport[1], 10);\n    } else if (chosenAltSvc[i].name == 'ma') {\n      frame.maxAge = parseInt(chosenAltSvc[i].value, 10);\n    }\n    // Otherwise, we just ignore this\n  }\n};\n\n// BLOCKED\n// ------------------------------------------------------------\n//\n// The BLOCKED frame (type=0xB) indicates that the sender is unable to send data\n// due to a closed flow control window.\n//\n// The BLOCKED frame does not define any flags and contains no payload.\n\nframeTypes[0xB] = 'BLOCKED';\n\nframeFlags.BLOCKED = [];\n\ntypeSpecificAttributes.BLOCKED = [];\n\nSerializer.BLOCKED = function writeBlocked(frame, buffers) {\n};\n\nDeserializer.BLOCKED = function readBlocked(buffer, frame) {\n};\n\n// [Error Codes](https://tools.ietf.org/html/rfc7540#section-7)\n// ------------------------------------------------------------\n\nvar errorCodes = [\n  'NO_ERROR',\n  'PROTOCOL_ERROR',\n  'INTERNAL_ERROR',\n  'FLOW_CONTROL_ERROR',\n  'SETTINGS_TIMEOUT',\n  'STREAM_CLOSED',\n  'FRAME_SIZE_ERROR',\n  'REFUSED_STREAM',\n  'CANCEL',\n  'COMPRESSION_ERROR',\n  'CONNECT_ERROR',\n  'ENHANCE_YOUR_CALM',\n  'INADEQUATE_SECURITY',\n  'HTTP_1_1_REQUIRED'\n];\n\n// Logging\n// -------\n\n// [Bunyan serializers](https://github.com/trentm/node-bunyan#serializers) to improve logging output\n// for debug messages emitted in this component.\nexports.serializers = {};\n\n// * `frame` serializer: it transforms data attributes from Buffers to hex strings and filters out\n//   flags that are not present.\nvar frameCounter = 0;\nexports.serializers.frame = function(frame) {\n  if (!frame) {\n    return null;\n  }\n\n  if ('id' in frame) {\n    return frame.id;\n  }\n\n  frame.id = frameCounter;\n  frameCounter += 1;\n\n  var logEntry = { id: frame.id };\n  genericAttributes.concat(typeSpecificAttributes[frame.type]).forEach(function(name) {\n    logEntry[name] = frame[name];\n  });\n\n  if (frame.data instanceof Buffer) {\n    if (logEntry.data.length > 50) {\n      logEntry.data = frame.data.slice(0, 47).toString('hex') + '...';\n    } else {\n      logEntry.data = frame.data.toString('hex');\n    }\n\n    if (!('length' in logEntry)) {\n      logEntry.length = frame.data.length;\n    }\n  }\n\n  if (frame.promised_stream instanceof Object) {\n    logEntry.promised_stream = 'stream-' + frame.promised_stream.id;\n  }\n\n  logEntry.flags = Object.keys(frame.flags || {}).filter(function(name) {\n    return frame.flags[name] === true;\n  });\n\n  return logEntry;\n};\n\n// * `data` serializer: it simply transforms a buffer to a hex string.\nexports.serializers.data = function(data) {\n  return data.toString('hex');\n};\n","/home/travis/build/npmtest/node-npmtest-http2/node_modules/http2/lib/protocol/compressor.js":"// The implementation of the [HTTP/2 Header Compression][http2-compression] spec is separated from\n// the 'integration' part which handles HEADERS and PUSH_PROMISE frames. The compression itself is\n// implemented in the first part of the file, and consists of three classes: `HeaderTable`,\n// `HeaderSetDecompressor` and `HeaderSetCompressor`. The two latter classes are\n// [Transform Stream][node-transform] subclasses that operate in [object mode][node-objectmode].\n// These transform chunks of binary data into `[name, value]` pairs and vice versa, and store their\n// state in `HeaderTable` instances.\n//\n// The 'integration' part is also implemented by two [Transform Stream][node-transform] subclasses\n// that operate in [object mode][node-objectmode]: the `Compressor` and the `Decompressor`. These\n// provide a layer between the [framer](framer.html) and the\n// [connection handling component](connection.html).\n//\n// [node-transform]: https://nodejs.org/api/stream.html#stream_class_stream_transform\n// [node-objectmode]: https://nodejs.org/api/stream.html#stream_new_stream_readable_options\n// [http2-compression]: https://tools.ietf.org/html/rfc7541\n\nexports.HeaderTable = HeaderTable;\nexports.HuffmanTable = HuffmanTable;\nexports.HeaderSetCompressor = HeaderSetCompressor;\nexports.HeaderSetDecompressor = HeaderSetDecompressor;\nexports.Compressor = Compressor;\nexports.Decompressor = Decompressor;\n\nvar TransformStream = require('stream').Transform;\nvar assert = require('assert');\nvar util = require('util');\n\n// Header compression\n// ==================\n\n// The HeaderTable class\n// ---------------------\n\n// The [Header Table] is a component used to associate headers to index values. It is basically an\n// ordered list of `[name, value]` pairs, so it's implemented as a subclass of `Array`.\n// In this implementation, the Header Table and the [Static Table] are handled as a single table.\n// [Header Table]: https://tools.ietf.org/html/rfc7541#section-2.3.2\n// [Static Table]: https://tools.ietf.org/html/rfc7541#section-2.3.1\nfunction HeaderTable(log, limit) {\n  var self = HeaderTable.staticTable.map(entryFromPair);\n  self._log = log;\n  self._limit = limit || DEFAULT_HEADER_TABLE_LIMIT;\n  self._staticLength = self.length;\n  self._size = 0;\n  self._enforceLimit = HeaderTable.prototype._enforceLimit;\n  self.add = HeaderTable.prototype.add;\n  self.setSizeLimit = HeaderTable.prototype.setSizeLimit;\n  return self;\n}\n\nfunction entryFromPair(pair) {\n  var entry = pair.slice();\n  entry._size = size(entry);\n  return entry;\n}\n\n// The encoder decides how to update the header table and as such can control how much memory is\n// used by the header table.  To limit the memory requirements on the decoder side, the header table\n// size is bounded.\n//\n// * The default header table size limit is 4096 bytes.\n// * The size of an entry is defined as follows: the size of an entry is the sum of its name's\n//   length in bytes, of its value's length in bytes and of 32 bytes.\n// * The size of a header table is the sum of the size of its entries.\nvar DEFAULT_HEADER_TABLE_LIMIT = 4096;\n\nfunction size(entry) {\n  return (new Buffer(entry[0] + entry[1], 'utf8')).length + 32;\n}\n\n// The `add(index, entry)` can be used to [manage the header table][tablemgmt]:\n// [tablemgmt]: https://tools.ietf.org/html/rfc7541#section-4\n//\n// * it pushes the new `entry` at the beggining of the table\n// * before doing such a modification, it has to be ensured that the header table size will stay\n//   lower than or equal to the header table size limit. To achieve this, entries are evicted from\n//   the end of the header table until the size of the header table is less than or equal to\n//   `(this._limit - entry.size)`, or until the table is empty.\n//\n//              <----------  Index Address Space ---------->\n//              <-- Static  Table -->  <-- Header  Table -->\n//              +---+-----------+---+  +---+-----------+---+\n//              | 0 |    ...    | k |  |k+1|    ...    | n |\n//              +---+-----------+---+  +---+-----------+---+\n//                                     ^                   |\n//                                     |                   V\n//                              Insertion Point       Drop Point\n\nHeaderTable.prototype._enforceLimit = function _enforceLimit(limit) {\n  var droppedEntries = [];\n  while ((this._size > 0) && (this._size > limit)) {\n    var dropped = this.pop();\n    this._size -= dropped._size;\n    droppedEntries.unshift(dropped);\n  }\n  return droppedEntries;\n};\n\nHeaderTable.prototype.add = function(entry) {\n  var limit = this._limit - entry._size;\n  var droppedEntries = this._enforceLimit(limit);\n\n  if (this._size <= limit) {\n    this.splice(this._staticLength, 0, entry);\n    this._size += entry._size;\n  }\n\n  return droppedEntries;\n};\n\n// The table size limit can be changed externally. In this case, the same eviction algorithm is used\nHeaderTable.prototype.setSizeLimit = function setSizeLimit(limit) {\n  this._limit = limit;\n  this._enforceLimit(this._limit);\n};\n\n// [The Static Table](https://tools.ietf.org/html/rfc7541#section-2.3.1)\n// ------------------\n\n// The table is generated with feeding the table from the spec to the following sed command:\n//\n//     sed -re \"s/\\s*\\| [0-9]+\\s*\\| ([^ ]*)/  [ '\\1'/g\" -e \"s/\\|\\s([^ ]*)/, '\\1'/g\" -e 's/ \\|/],/g'\n\nHeaderTable.staticTable  = [\n  [ ':authority'                  , ''            ],\n  [ ':method'                     , 'GET'         ],\n  [ ':method'                     , 'POST'        ],\n  [ ':path'                       , '/'           ],\n  [ ':path'                       , '/index.html' ],\n  [ ':scheme'                     , 'http'        ],\n  [ ':scheme'                     , 'https'       ],\n  [ ':status'                     , '200'         ],\n  [ ':status'                     , '204'         ],\n  [ ':status'                     , '206'         ],\n  [ ':status'                     , '304'         ],\n  [ ':status'                     , '400'         ],\n  [ ':status'                     , '404'         ],\n  [ ':status'                     , '500'         ],\n  [ 'accept-charset'              , ''            ],\n  [ 'accept-encoding'             , 'gzip, deflate'],\n  [ 'accept-language'             , ''            ],\n  [ 'accept-ranges'               , ''            ],\n  [ 'accept'                      , ''            ],\n  [ 'access-control-allow-origin' , ''            ],\n  [ 'age'                         , ''            ],\n  [ 'allow'                       , ''            ],\n  [ 'authorization'               , ''            ],\n  [ 'cache-control'               , ''            ],\n  [ 'content-disposition'         , ''            ],\n  [ 'content-encoding'            , ''            ],\n  [ 'content-language'            , ''            ],\n  [ 'content-length'              , ''            ],\n  [ 'content-location'            , ''            ],\n  [ 'content-range'               , ''            ],\n  [ 'content-type'                , ''            ],\n  [ 'cookie'                      , ''            ],\n  [ 'date'                        , ''            ],\n  [ 'etag'                        , ''            ],\n  [ 'expect'                      , ''            ],\n  [ 'expires'                     , ''            ],\n  [ 'from'                        , ''            ],\n  [ 'host'                        , ''            ],\n  [ 'if-match'                    , ''            ],\n  [ 'if-modified-since'           , ''            ],\n  [ 'if-none-match'               , ''            ],\n  [ 'if-range'                    , ''            ],\n  [ 'if-unmodified-since'         , ''            ],\n  [ 'last-modified'               , ''            ],\n  [ 'link'                        , ''            ],\n  [ 'location'                    , ''            ],\n  [ 'max-forwards'                , ''            ],\n  [ 'proxy-authenticate'          , ''            ],\n  [ 'proxy-authorization'         , ''            ],\n  [ 'range'                       , ''            ],\n  [ 'referer'                     , ''            ],\n  [ 'refresh'                     , ''            ],\n  [ 'retry-after'                 , ''            ],\n  [ 'server'                      , ''            ],\n  [ 'set-cookie'                  , ''            ],\n  [ 'strict-transport-security'   , ''            ],\n  [ 'transfer-encoding'           , ''            ],\n  [ 'user-agent'                  , ''            ],\n  [ 'vary'                        , ''            ],\n  [ 'via'                         , ''            ],\n  [ 'www-authenticate'            , ''            ]\n];\n\n// The HeaderSetDecompressor class\n// -------------------------------\n\n// A `HeaderSetDecompressor` instance is a transform stream that can be used to *decompress a\n// single header set*. Its input is a stream of binary data chunks and its output is a stream of\n// `[name, value]` pairs.\n//\n// Currently, it is not a proper streaming decompressor implementation, since it buffer its input\n// until the end os the stream, and then processes the whole header block at once.\n\nutil.inherits(HeaderSetDecompressor, TransformStream);\nfunction HeaderSetDecompressor(log, table) {\n  TransformStream.call(this, { objectMode: true });\n\n  this._log = log.child({ component: 'compressor' });\n  this._table = table;\n  this._chunks = [];\n}\n\n// `_transform` is the implementation of the [corresponding virtual function][_transform] of the\n// TransformStream class. It collects the data chunks for later processing.\n// [_transform]: https://nodejs.org/api/stream.html#stream_transform_transform_chunk_encoding_callback\nHeaderSetDecompressor.prototype._transform = function _transform(chunk, encoding, callback) {\n  this._chunks.push(chunk);\n  callback();\n};\n\n// `execute(rep)` executes the given [header representation][representation].\n// [representation]: https://tools.ietf.org/html/rfc7541#section-6\n\n// The *JavaScript object representation* of a header representation:\n//\n//     {\n//       name: String || Integer,  // string literal or index\n//       value: String || Integer, // string literal or index\n//       index: Boolean            // with or without indexing\n//     }\n//\n// *Important:* to ease the indexing of the header table, indexes start at 0 instead of 1.\n//\n// Examples:\n//\n//     Indexed:\n//     { name: 2  , value: 2  , index: false }\n//     Literal:\n//     { name: 2  , value: 'X', index: false } // without indexing\n//     { name: 2  , value: 'Y', index: true  } // with indexing\n//     { name: 'A', value: 'Z', index: true  } // with indexing, literal name\nHeaderSetDecompressor.prototype._execute = function _execute(rep) {\n  this._log.trace({ key: rep.name, value: rep.value, index: rep.index },\n                  'Executing header representation');\n\n  var entry, pair;\n\n  if (rep.contextUpdate) {\n    this._table.setSizeLimit(rep.newMaxSize);\n  }\n\n  // * An _indexed representation_ entails the following actions:\n  //   * The header field corresponding to the referenced entry is emitted\n  else if (typeof rep.value === 'number') {\n    var index = rep.value;\n    entry = this._table[index];\n\n    pair = entry.slice();\n    this.push(pair);\n  }\n\n  // * A _literal representation_ that is _not added_ to the header table entails the following\n  //   action:\n  //   * The header is emitted.\n  // * A _literal representation_ that is _added_ to the header table entails the following further\n  //   actions:\n  //   * The header is added to the header table.\n  //   * The header is emitted.\n  else {\n    if (typeof rep.name === 'number') {\n      pair = [this._table[rep.name][0], rep.value];\n    } else {\n      pair = [rep.name, rep.value];\n    }\n\n    if (rep.index) {\n      entry = entryFromPair(pair);\n      this._table.add(entry);\n    }\n\n    this.push(pair);\n  }\n};\n\n// `_flush` is the implementation of the [corresponding virtual function][_flush] of the\n// TransformStream class. The whole decompressing process is done in `_flush`. It gets called when\n// the input stream is over.\n// [_flush]: https://nodejs.org/api/stream.html#stream_transform_flush_callback\nHeaderSetDecompressor.prototype._flush = function _flush(callback) {\n  var buffer = concat(this._chunks);\n\n  // * processes the header representations\n  buffer.cursor = 0;\n  while (buffer.cursor < buffer.length) {\n    this._execute(HeaderSetDecompressor.header(buffer));\n  }\n\n  callback();\n};\n\n// The HeaderSetCompressor class\n// -----------------------------\n\n// A `HeaderSetCompressor` instance is a transform stream that can be used to *compress a single\n// header set*. Its input is a stream of `[name, value]` pairs and its output is a stream of\n// binary data chunks.\n//\n// It is a real streaming compressor, since it does not wait until the header set is complete.\n//\n// The compression algorithm is (intentionally) not specified by the spec. Therefore, the current\n// compression algorithm can probably be improved in the future.\n\nutil.inherits(HeaderSetCompressor, TransformStream);\nfunction HeaderSetCompressor(log, table) {\n  TransformStream.call(this, { objectMode: true });\n\n  this._log = log.child({ component: 'compressor' });\n  this._table = table;\n  this.push = TransformStream.prototype.push.bind(this);\n}\n\nHeaderSetCompressor.prototype.send = function send(rep) {\n  this._log.trace({ key: rep.name, value: rep.value, index: rep.index },\n                  'Emitting header representation');\n\n  if (!rep.chunks) {\n    rep.chunks = HeaderSetCompressor.header(rep);\n  }\n  rep.chunks.forEach(this.push);\n};\n\n// `_transform` is the implementation of the [corresponding virtual function][_transform] of the\n// TransformStream class. It processes the input headers one by one:\n// [_transform]: https://nodejs.org/api/stream.html#stream_transform_transform_chunk_encoding_callback\nHeaderSetCompressor.prototype._transform = function _transform(pair, encoding, callback) {\n  var name = pair[0].toLowerCase();\n  var value = pair[1];\n  var entry, rep;\n\n  // * tries to find full (name, value) or name match in the header table\n  var nameMatch = -1, fullMatch = -1;\n  for (var droppedIndex = 0; droppedIndex < this._table.length; droppedIndex++) {\n    entry = this._table[droppedIndex];\n    if (entry[0] === name) {\n      if (entry[1] === value) {\n        fullMatch = droppedIndex;\n        break;\n      } else if (nameMatch === -1) {\n        nameMatch = droppedIndex;\n      }\n    }\n  }\n\n  var mustNeverIndex = ((name === 'cookie' && value.length < 20) ||\n                        (name === 'set-cookie' && value.length < 20) ||\n                        name === 'authorization');\n\n  if (fullMatch !== -1 && !mustNeverIndex) {\n    this.send({ name: fullMatch, value: fullMatch, index: false });\n  }\n\n  // * otherwise, it will be a literal representation (with a name index if there's a name match)\n  else {\n    entry = entryFromPair(pair);\n\n    var indexing = (entry._size < this._table._limit / 2) && !mustNeverIndex;\n\n    if (indexing) {\n      this._table.add(entry);\n    }\n\n    this.send({ name: (nameMatch !== -1) ? nameMatch : name, value: value, index: indexing, mustNeverIndex: mustNeverIndex, contextUpdate: false });\n  }\n\n  callback();\n};\n\n// `_flush` is the implementation of the [corresponding virtual function][_flush] of the\n// TransformStream class. It gets called when there's no more header to compress. The final step:\n// [_flush]: https://nodejs.org/api/stream.html#stream_transform_flush_callback\nHeaderSetCompressor.prototype._flush = function _flush(callback) {\n  callback();\n};\n\n// [Detailed Format](https://tools.ietf.org/html/rfc7541#section-5)\n// -----------------\n\n// ### Integer representation ###\n//\n// The algorithm to represent an integer I is as follows:\n//\n// 1. If I < 2^N - 1, encode I on N bits\n// 2. Else, encode 2^N - 1 on N bits and do the following steps:\n//    1. Set I to (I - (2^N - 1)) and Q to 1\n//    2. While Q > 0\n//       1. Compute Q and R, quotient and remainder of I divided by 2^7\n//       2. If Q is strictly greater than 0, write one 1 bit; otherwise, write one 0 bit\n//       3. Encode R on the next 7 bits\n//       4. I = Q\n\nHeaderSetCompressor.integer = function writeInteger(I, N) {\n  var limit = Math.pow(2,N) - 1;\n  if (I < limit) {\n    return [new Buffer([I])];\n  }\n\n  var bytes = [];\n  if (N !== 0) {\n    bytes.push(limit);\n  }\n  I -= limit;\n\n  var Q = 1, R;\n  while (Q > 0) {\n    Q = Math.floor(I / 128);\n    R = I % 128;\n\n    if (Q > 0) {\n      R += 128;\n    }\n    bytes.push(R);\n\n    I = Q;\n  }\n\n  return [new Buffer(bytes)];\n};\n\n// The inverse algorithm:\n//\n// 1. Set I to the number coded on the lower N bits of the first byte\n// 2. If I is smaller than 2^N - 1 then return I\n// 2. Else the number is encoded on more than one byte, so do the following steps:\n//    1. Set M to 0\n//    2. While returning with I\n//       1. Let B be the next byte (the first byte if N is 0)\n//       2. Read out the lower 7 bits of B and multiply it with 2^M\n//       3. Increase I with this number\n//       4. Increase M by 7\n//       5. Return I if the most significant bit of B is 0\n\nHeaderSetDecompressor.integer = function readInteger(buffer, N) {\n  var limit = Math.pow(2,N) - 1;\n\n  var I = buffer[buffer.cursor] & limit;\n  if (N !== 0) {\n    buffer.cursor += 1;\n  }\n\n  if (I === limit) {\n    var M = 0;\n    do {\n      I += (buffer[buffer.cursor] & 127) << M;\n      M += 7;\n      buffer.cursor += 1;\n    } while (buffer[buffer.cursor - 1] & 128);\n  }\n\n  return I;\n};\n\n// ### Huffman Encoding ###\n\nfunction HuffmanTable(table) {\n  function createTree(codes, position) {\n    if (codes.length === 1) {\n      return [table.indexOf(codes[0])];\n    }\n\n    else {\n      position = position || 0;\n      var zero = [];\n      var one = [];\n      for (var i = 0; i < codes.length; i++) {\n        var string = codes[i];\n        if (string[position] === '0') {\n          zero.push(string);\n        } else {\n          one.push(string);\n        }\n      }\n      return [createTree(zero, position + 1), createTree(one, position + 1)];\n    }\n  }\n\n  this.tree = createTree(table);\n\n  this.codes = table.map(function(bits) {\n    return parseInt(bits, 2);\n  });\n  this.lengths = table.map(function(bits) {\n    return bits.length;\n  });\n}\n\nHuffmanTable.prototype.encode = function encode(buffer) {\n  var result = [];\n  var space = 8;\n\n  function add(data) {\n    if (space === 8) {\n      result.push(data);\n    } else {\n      result[result.length - 1] |= data;\n    }\n  }\n\n  for (var i = 0; i < buffer.length; i++) {\n    var byte = buffer[i];\n    var code = this.codes[byte];\n    var length = this.lengths[byte];\n\n    while (length !== 0) {\n      if (space >= length) {\n        add(code << (space - length));\n        code = 0;\n        space -= length;\n        length = 0;\n      } else {\n        var shift = length - space;\n        var msb = code >> shift;\n        add(msb);\n        code -= msb << shift;\n        length -= space;\n        space = 0;\n      }\n\n      if (space === 0) {\n        space = 8;\n      }\n    }\n  }\n\n  if (space !== 8) {\n    add(this.codes[256] >> (this.lengths[256] - space));\n  }\n\n  return new Buffer(result);\n};\n\nHuffmanTable.prototype.decode = function decode(buffer) {\n  var result = [];\n  var subtree = this.tree;\n\n  for (var i = 0; i < buffer.length; i++) {\n    var byte = buffer[i];\n\n    for (var j = 0; j < 8; j++) {\n      var bit = (byte & 128) ? 1 : 0;\n      byte = byte << 1;\n\n      subtree = subtree[bit];\n      if (subtree.length === 1) {\n        result.push(subtree[0]);\n        subtree = this.tree;\n      }\n    }\n  }\n\n  return new Buffer(result);\n};\n\n// The initializer arrays for the Huffman tables are generated with feeding the tables from the\n// spec to this sed command:\n//\n//     sed -e \"s/^.* [|]//g\" -e \"s/|//g\" -e \"s/ .*//g\" -e \"s/^/  '/g\" -e \"s/$/',/g\"\n\nHuffmanTable.huffmanTable = new HuffmanTable([\n  '1111111111000',\n  '11111111111111111011000',\n  '1111111111111111111111100010',\n  '1111111111111111111111100011',\n  '1111111111111111111111100100',\n  '1111111111111111111111100101',\n  '1111111111111111111111100110',\n  '1111111111111111111111100111',\n  '1111111111111111111111101000',\n  '111111111111111111101010',\n  '111111111111111111111111111100',\n  '1111111111111111111111101001',\n  '1111111111111111111111101010',\n  '111111111111111111111111111101',\n  '1111111111111111111111101011',\n  '1111111111111111111111101100',\n  '1111111111111111111111101101',\n  '1111111111111111111111101110',\n  '1111111111111111111111101111',\n  '1111111111111111111111110000',\n  '1111111111111111111111110001',\n  '1111111111111111111111110010',\n  '111111111111111111111111111110',\n  '1111111111111111111111110011',\n  '1111111111111111111111110100',\n  '1111111111111111111111110101',\n  '1111111111111111111111110110',\n  '1111111111111111111111110111',\n  '1111111111111111111111111000',\n  '1111111111111111111111111001',\n  '1111111111111111111111111010',\n  '1111111111111111111111111011',\n  '010100',\n  '1111111000',\n  '1111111001',\n  '111111111010',\n  '1111111111001',\n  '010101',\n  '11111000',\n  '11111111010',\n  '1111111010',\n  '1111111011',\n  '11111001',\n  '11111111011',\n  '11111010',\n  '010110',\n  '010111',\n  '011000',\n  '00000',\n  '00001',\n  '00010',\n  '011001',\n  '011010',\n  '011011',\n  '011100',\n  '011101',\n  '011110',\n  '011111',\n  '1011100',\n  '11111011',\n  '111111111111100',\n  '100000',\n  '111111111011',\n  '1111111100',\n  '1111111111010',\n  '100001',\n  '1011101',\n  '1011110',\n  '1011111',\n  '1100000',\n  '1100001',\n  '1100010',\n  '1100011',\n  '1100100',\n  '1100101',\n  '1100110',\n  '1100111',\n  '1101000',\n  '1101001',\n  '1101010',\n  '1101011',\n  '1101100',\n  '1101101',\n  '1101110',\n  '1101111',\n  '1110000',\n  '1110001',\n  '1110010',\n  '11111100',\n  '1110011',\n  '11111101',\n  '1111111111011',\n  '1111111111111110000',\n  '1111111111100',\n  '11111111111100',\n  '100010',\n  '111111111111101',\n  '00011',\n  '100011',\n  '00100',\n  '100100',\n  '00101',\n  '100101',\n  '100110',\n  '100111',\n  '00110',\n  '1110100',\n  '1110101',\n  '101000',\n  '101001',\n  '101010',\n  '00111',\n  '101011',\n  '1110110',\n  '101100',\n  '01000',\n  '01001',\n  '101101',\n  '1110111',\n  '1111000',\n  '1111001',\n  '1111010',\n  '1111011',\n  '111111111111110',\n  '11111111100',\n  '11111111111101',\n  '1111111111101',\n  '1111111111111111111111111100',\n  '11111111111111100110',\n  '1111111111111111010010',\n  '11111111111111100111',\n  '11111111111111101000',\n  '1111111111111111010011',\n  '1111111111111111010100',\n  '1111111111111111010101',\n  '11111111111111111011001',\n  '1111111111111111010110',\n  '11111111111111111011010',\n  '11111111111111111011011',\n  '11111111111111111011100',\n  '11111111111111111011101',\n  '11111111111111111011110',\n  '111111111111111111101011',\n  '11111111111111111011111',\n  '111111111111111111101100',\n  '111111111111111111101101',\n  '1111111111111111010111',\n  '11111111111111111100000',\n  '111111111111111111101110',\n  '11111111111111111100001',\n  '11111111111111111100010',\n  '11111111111111111100011',\n  '11111111111111111100100',\n  '111111111111111011100',\n  '1111111111111111011000',\n  '11111111111111111100101',\n  '1111111111111111011001',\n  '11111111111111111100110',\n  '11111111111111111100111',\n  '111111111111111111101111',\n  '1111111111111111011010',\n  '111111111111111011101',\n  '11111111111111101001',\n  '1111111111111111011011',\n  '1111111111111111011100',\n  '11111111111111111101000',\n  '11111111111111111101001',\n  '111111111111111011110',\n  '11111111111111111101010',\n  '1111111111111111011101',\n  '1111111111111111011110',\n  '111111111111111111110000',\n  '111111111111111011111',\n  '1111111111111111011111',\n  '11111111111111111101011',\n  '11111111111111111101100',\n  '111111111111111100000',\n  '111111111111111100001',\n  '1111111111111111100000',\n  '111111111111111100010',\n  '11111111111111111101101',\n  '1111111111111111100001',\n  '11111111111111111101110',\n  '11111111111111111101111',\n  '11111111111111101010',\n  '1111111111111111100010',\n  '1111111111111111100011',\n  '1111111111111111100100',\n  '11111111111111111110000',\n  '1111111111111111100101',\n  '1111111111111111100110',\n  '11111111111111111110001',\n  '11111111111111111111100000',\n  '11111111111111111111100001',\n  '11111111111111101011',\n  '1111111111111110001',\n  '1111111111111111100111',\n  '11111111111111111110010',\n  '1111111111111111101000',\n  '1111111111111111111101100',\n  '11111111111111111111100010',\n  '11111111111111111111100011',\n  '11111111111111111111100100',\n  '111111111111111111111011110',\n  '111111111111111111111011111',\n  '11111111111111111111100101',\n  '111111111111111111110001',\n  '1111111111111111111101101',\n  '1111111111111110010',\n  '111111111111111100011',\n  '11111111111111111111100110',\n  '111111111111111111111100000',\n  '111111111111111111111100001',\n  '11111111111111111111100111',\n  '111111111111111111111100010',\n  '111111111111111111110010',\n  '111111111111111100100',\n  '111111111111111100101',\n  '11111111111111111111101000',\n  '11111111111111111111101001',\n  '1111111111111111111111111101',\n  '111111111111111111111100011',\n  '111111111111111111111100100',\n  '111111111111111111111100101',\n  '11111111111111101100',\n  '111111111111111111110011',\n  '11111111111111101101',\n  '111111111111111100110',\n  '1111111111111111101001',\n  '111111111111111100111',\n  '111111111111111101000',\n  '11111111111111111110011',\n  '1111111111111111101010',\n  '1111111111111111101011',\n  '1111111111111111111101110',\n  '1111111111111111111101111',\n  '111111111111111111110100',\n  '111111111111111111110101',\n  '11111111111111111111101010',\n  '11111111111111111110100',\n  '11111111111111111111101011',\n  '111111111111111111111100110',\n  '11111111111111111111101100',\n  '11111111111111111111101101',\n  '111111111111111111111100111',\n  '111111111111111111111101000',\n  '111111111111111111111101001',\n  '111111111111111111111101010',\n  '111111111111111111111101011',\n  '1111111111111111111111111110',\n  '111111111111111111111101100',\n  '111111111111111111111101101',\n  '111111111111111111111101110',\n  '111111111111111111111101111',\n  '111111111111111111111110000',\n  '11111111111111111111101110',\n  '111111111111111111111111111111'\n]);\n\n// ### String literal representation ###\n//\n// Literal **strings** can represent header names or header values. There's two variant of the\n// string encoding:\n//\n// String literal with Huffman encoding:\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 1 |  Value Length Prefix (7)  |\n//     +---+---+---+---+---+---+---+---+\n//     |   Value Length (0-N bytes)    |\n//     +---+---+---+---+---+---+---+---+\n//     ...\n//     +---+---+---+---+---+---+---+---+\n//     | Huffman Encoded Data  |Padding|\n//     +---+---+---+---+---+---+---+---+\n//\n// String literal without Huffman encoding:\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 |  Value Length Prefix (7)  |\n//     +---+---+---+---+---+---+---+---+\n//     |   Value Length (0-N bytes)    |\n//     +---+---+---+---+---+---+---+---+\n//     ...\n//     +---+---+---+---+---+---+---+---+\n//     |  Field Bytes Without Encoding |\n//     +---+---+---+---+---+---+---+---+\n\nHeaderSetCompressor.string = function writeString(str) {\n  str = new Buffer(str, 'utf8');\n\n  var huffman = HuffmanTable.huffmanTable.encode(str);\n  if (huffman.length < str.length) {\n    var length = HeaderSetCompressor.integer(huffman.length, 7);\n    length[0][0] |= 128;\n    return length.concat(huffman);\n  }\n\n  else {\n    length = HeaderSetCompressor.integer(str.length, 7);\n    return length.concat(str);\n  }\n};\n\nHeaderSetDecompressor.string = function readString(buffer) {\n  var huffman = buffer[buffer.cursor] & 128;\n  var length = HeaderSetDecompressor.integer(buffer, 7);\n  var encoded = buffer.slice(buffer.cursor, buffer.cursor + length);\n  buffer.cursor += length;\n  return (huffman ? HuffmanTable.huffmanTable.decode(encoded) : encoded).toString('utf8');\n};\n\n// ### Header represenations ###\n\n// The JavaScript object representation is described near the\n// `HeaderSetDecompressor.prototype._execute()` method definition.\n//\n// **All binary header representations** start with a prefix signaling the representation type and\n// an index represented using prefix coded integers:\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 1 |        Index (7+)         |  Indexed Representation\n//     +---+---------------------------+\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 | 1 |      Index (6+)       |\n//     +---+---+---+-------------------+  Literal w/ Indexing\n//     |       Value Length (8+)       |\n//     +-------------------------------+  w/ Indexed Name\n//     | Value String (Length octets)  |\n//     +-------------------------------+\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 | 1 |           0           |\n//     +---+---+---+-------------------+\n//     |       Name Length (8+)        |\n//     +-------------------------------+  Literal w/ Indexing\n//     |  Name String (Length octets)  |\n//     +-------------------------------+  w/ New Name\n//     |       Value Length (8+)       |\n//     +-------------------------------+\n//     | Value String (Length octets)  |\n//     +-------------------------------+\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 | 0 | 0 | 0 |  Index (4+)   |\n//     +---+---+---+-------------------+  Literal w/o Incremental Indexing\n//     |       Value Length (8+)       |\n//     +-------------------------------+  w/ Indexed Name\n//     | Value String (Length octets)  |\n//     +-------------------------------+\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 | 0 | 0 | 0 |       0       |\n//     +---+---+---+-------------------+\n//     |       Name Length (8+)        |\n//     +-------------------------------+  Literal w/o Incremental Indexing\n//     |  Name String (Length octets)  |\n//     +-------------------------------+  w/ New Name\n//     |       Value Length (8+)       |\n//     +-------------------------------+\n//     | Value String (Length octets)  |\n//     +-------------------------------+\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 | 0 | 0 | 1 |  Index (4+)   |\n//     +---+---+---+-------------------+  Literal never indexed\n//     |       Value Length (8+)       |\n//     +-------------------------------+  w/ Indexed Name\n//     | Value String (Length octets)  |\n//     +-------------------------------+\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 | 0 | 0 | 1 |       0       |\n//     +---+---+---+-------------------+\n//     |       Name Length (8+)        |\n//     +-------------------------------+  Literal never indexed\n//     |  Name String (Length octets)  |\n//     +-------------------------------+  w/ New Name\n//     |       Value Length (8+)       |\n//     +-------------------------------+\n//     | Value String (Length octets)  |\n//     +-------------------------------+\n//\n// The **Indexed Representation** consists of the 1-bit prefix and the Index that is represented as\n// a 7-bit prefix coded integer and nothing else.\n//\n// After the first bits, **all literal representations** specify the header name, either as a\n// pointer to the Header Table (Index) or a string literal. When the string literal representation\n// is used, the Index is set to 0 and the string literal starts at the second byte.\n//\n// For **all literal representations**, the specification of the header value comes next. It is\n// always represented as a string.\n\nvar representations = {\n  indexed             : { prefix: 7, pattern: 0x80 },\n  literalIncremental  : { prefix: 6, pattern: 0x40 },\n  contextUpdate       : { prefix: 0, pattern: 0x20 },\n  literalNeverIndexed : { prefix: 4, pattern: 0x10 },\n  literal             : { prefix: 4, pattern: 0x00 }\n};\n\nHeaderSetCompressor.header = function writeHeader(header) {\n  var representation, buffers = [];\n\n  if (header.contextUpdate) {\n    representation = representations.contextUpdate;\n  } else if (typeof header.value === 'number') {\n    representation = representations.indexed;\n  } else if (header.index) {\n    representation = representations.literalIncremental;\n  } else if (header.mustNeverIndex) {\n    representation = representations.literalNeverIndexed;\n  } else {\n    representation = representations.literal;\n  }\n\n  if (representation === representations.contextUpdate) {\n    buffers.push(HeaderSetCompressor.integer(header.newMaxSize, 5));\n  }\n\n  else if (representation === representations.indexed) {\n    buffers.push(HeaderSetCompressor.integer(header.value + 1, representation.prefix));\n  }\n\n  else {\n    if (typeof header.name === 'number') {\n      buffers.push(HeaderSetCompressor.integer(header.name + 1, representation.prefix));\n    } else {\n      buffers.push(HeaderSetCompressor.integer(0, representation.prefix));\n      buffers.push(HeaderSetCompressor.string(header.name));\n    }\n    buffers.push(HeaderSetCompressor.string(header.value));\n  }\n\n  buffers[0][0][0] |= representation.pattern;\n\n  return Array.prototype.concat.apply([], buffers); // array of arrays of buffers -> array of buffers\n};\n\nHeaderSetDecompressor.header = function readHeader(buffer) {\n  var representation, header = {};\n\n  var firstByte = buffer[buffer.cursor];\n  if (firstByte & 0x80) {\n    representation = representations.indexed;\n  } else if (firstByte & 0x40) {\n    representation = representations.literalIncremental;\n  } else if (firstByte & 0x20) {\n    representation = representations.contextUpdate;\n  } else if (firstByte & 0x10) {\n    representation = representations.literalNeverIndexed;\n  } else {\n    representation = representations.literal;\n  }\n\n  header.value = header.name = -1;\n  header.index = false;\n  header.contextUpdate = false;\n  header.newMaxSize = 0;\n  header.mustNeverIndex = false;\n\n  if (representation === representations.contextUpdate) {\n    header.contextUpdate = true;\n    header.newMaxSize = HeaderSetDecompressor.integer(buffer, 5);\n  }\n\n  else if (representation === representations.indexed) {\n    header.value = header.name = HeaderSetDecompressor.integer(buffer, representation.prefix) - 1;\n  }\n\n  else {\n    header.name = HeaderSetDecompressor.integer(buffer, representation.prefix) - 1;\n    if (header.name === -1) {\n      header.name = HeaderSetDecompressor.string(buffer);\n    }\n    header.value = HeaderSetDecompressor.string(buffer);\n    header.index = (representation === representations.literalIncremental);\n    header.mustNeverIndex = (representation === representations.literalNeverIndexed);\n  }\n\n  return header;\n};\n\n// Integration with HTTP/2\n// =======================\n\n// This section describes the interaction between the compressor/decompressor and the rest of the\n// HTTP/2 implementation. The `Compressor` and the `Decompressor` makes up a layer between the\n// [framer](framer.html) and the [connection handling component](connection.html). They let most\n// frames pass through, except HEADERS and PUSH_PROMISE frames. They convert the frames between\n// these two representations:\n//\n//     {                                   {\n//      type: 'HEADERS',                    type: 'HEADERS',\n//      flags: {},                          flags: {},\n//      stream: 1,               <===>      stream: 1,\n//      headers: {                          data: Buffer\n//       N1: 'V1',                         }\n//       N2: ['V1', 'V2', ...],\n//       // ...\n//      }\n//     }\n//\n// There are possibly several binary frame that belong to a single non-binary frame.\n\nvar MAX_HTTP_PAYLOAD_SIZE = 16384;\n\n// The Compressor class\n// --------------------\n\n// The Compressor transform stream is basically stateless.\nutil.inherits(Compressor, TransformStream);\nfunction Compressor(log, type) {\n  TransformStream.call(this, { objectMode: true });\n\n  this._log = log.child({ component: 'compressor' });\n\n  assert((type === 'REQUEST') || (type === 'RESPONSE'));\n  this._table = new HeaderTable(this._log);\n\n  this.tableSizeChangePending = false;\n  this.lowestTableSizePending = 0;\n  this.tableSizeSetting = DEFAULT_HEADER_TABLE_LIMIT;\n}\n\n// Changing the header table size\nCompressor.prototype.setTableSizeLimit = function setTableSizeLimit(size) {\n  this._table.setSizeLimit(size);\n  if (!this.tableSizeChangePending || size < this.lowestTableSizePending) {\n    this.lowestTableSizePending = size;\n  }\n  this.tableSizeSetting = size;\n  this.tableSizeChangePending = true;\n};\n\n// `compress` takes a header set, and compresses it using a new `HeaderSetCompressor` stream\n// instance. This means that from now on, the advantages of streaming header encoding are lost,\n// but the API becomes simpler.\nCompressor.prototype.compress = function compress(headers) {\n  var compressor = new HeaderSetCompressor(this._log, this._table);\n\n  if (this.tableSizeChangePending) {\n    if (this.lowestTableSizePending < this.tableSizeSetting) {\n      compressor.send({contextUpdate: true, newMaxSize: this.lowestTableSizePending,\n                       name: \"\", value: \"\", index: 0});\n    }\n    compressor.send({contextUpdate: true, newMaxSize: this.tableSizeSetting,\n                     name: \"\", value: \"\", index: 0});\n    this.tableSizeChangePending = false;\n  }\n  var colonHeaders = [];\n  var nonColonHeaders = [];\n\n  // To ensure we send colon headers first\n  for (var name in headers) {\n    if (name.trim()[0] === ':') {\n      colonHeaders.push(name);\n    } else {\n      nonColonHeaders.push(name);\n    }\n  }\n\n  function compressHeader(name) {\n    var value = headers[name];\n    name = String(name).toLowerCase();\n\n    // * To allow for better compression efficiency, the Cookie header field MAY be split into\n    //   separate header fields, each with one or more cookie-pairs.\n    if (name == 'cookie') {\n      if (!(value instanceof Array)) {\n        value = [value];\n      }\n      value = Array.prototype.concat.apply([], value.map(function(cookie) {\n        return String(cookie).split(';').map(trim);\n      }));\n    }\n\n    if (value instanceof Array) {\n      for (var i = 0; i < value.length; i++) {\n        compressor.write([name, String(value[i])]);\n      }\n    } else {\n      compressor.write([name, String(value)]);\n    }\n  }\n\n  colonHeaders.forEach(compressHeader);\n  nonColonHeaders.forEach(compressHeader);\n\n  compressor.end();\n\n  var chunk, chunks = [];\n  while (chunk = compressor.read()) {\n    chunks.push(chunk);\n  }\n  return concat(chunks);\n};\n\n// When a `frame` arrives\nCompressor.prototype._transform = function _transform(frame, encoding, done) {\n  // * and it is a HEADERS or PUSH_PROMISE frame\n  //   * it generates a header block using the compress method\n  //   * cuts the header block into `chunks` that are not larger than `MAX_HTTP_PAYLOAD_SIZE`\n  //   * for each chunk, it pushes out a chunk frame that is identical to the original, except\n  //     the `data` property which holds the given chunk, the type of the frame which is always\n  //     CONTINUATION except for the first frame, and the END_HEADERS/END_PUSH_STREAM flag that\n  //     marks the last frame and the END_STREAM flag which is always false before the end\n  if (frame.type === 'HEADERS' || frame.type === 'PUSH_PROMISE') {\n    var buffer = this.compress(frame.headers);\n\n    // This will result in CONTINUATIONs from a PUSH_PROMISE being 4 bytes shorter than they could\n    // be, but that's not the end of the world, and it prevents us from going over MAX_HTTP_PAYLOAD_SIZE\n    // on the initial PUSH_PROMISE frame.\n    var adjustment = frame.type === 'PUSH_PROMISE' ? 4 : 0;\n    var chunks = cut(buffer, MAX_HTTP_PAYLOAD_SIZE - adjustment);\n\n    for (var i = 0; i < chunks.length; i++) {\n      var chunkFrame;\n      var first = (i === 0);\n      var last = (i === chunks.length - 1);\n\n      if (first) {\n        chunkFrame = util._extend({}, frame);\n        chunkFrame.flags = util._extend({}, frame.flags);\n        chunkFrame.flags['END_' + frame.type] = last;\n      } else {\n        chunkFrame = {\n          type: 'CONTINUATION',\n          flags: { END_HEADERS: last },\n          stream: frame.stream\n        };\n      }\n      chunkFrame.data = chunks[i];\n\n      this.push(chunkFrame);\n    }\n  }\n\n  // * otherwise, the frame is forwarded without taking any action\n  else {\n    this.push(frame);\n  }\n\n  done();\n};\n\n// The Decompressor class\n// ----------------------\n\n// The Decompressor is a stateful transform stream, since it has to collect multiple frames first,\n// and the decoding comes after unifying the payload of those frames.\n//\n// If there's a frame in progress, `this._inProgress` is `true`. The frames are collected in\n// `this._frames`, and the type of the frame and the stream identifier is stored in `this._type`\n// and `this._stream` respectively.\nutil.inherits(Decompressor, TransformStream);\nfunction Decompressor(log, type) {\n  TransformStream.call(this, { objectMode: true });\n\n  this._log = log.child({ component: 'compressor' });\n\n  assert((type === 'REQUEST') || (type === 'RESPONSE'));\n  this._table = new HeaderTable(this._log);\n\n  this._inProgress = false;\n  this._base = undefined;\n}\n\n// Changing the header table size\nDecompressor.prototype.setTableSizeLimit = function setTableSizeLimit(size) {\n  this._table.setSizeLimit(size);\n};\n\n// `decompress` takes a full header block, and decompresses it using a new `HeaderSetDecompressor`\n// stream instance. This means that from now on, the advantages of streaming header decoding are\n// lost, but the API becomes simpler.\nDecompressor.prototype.decompress = function decompress(block) {\n  var decompressor = new HeaderSetDecompressor(this._log, this._table);\n  decompressor.end(block);\n\n  var seenNonColonHeader = false;\n  var headers = {};\n  var pair;\n  while (pair = decompressor.read()) {\n    var name = pair[0];\n    var value = pair[1];\n    var isColonHeader = (name.trim()[0] === ':');\n    if (seenNonColonHeader && isColonHeader) {\n        this.emit('error', 'PROTOCOL_ERROR');\n        return headers;\n    }\n    seenNonColonHeader = !isColonHeader;\n    if (name in headers) {\n      if (headers[name] instanceof Array) {\n        headers[name].push(value);\n      } else {\n        headers[name] = [headers[name], value];\n      }\n    } else {\n      headers[name] = value;\n    }\n  }\n\n  // * If there are multiple Cookie header fields after decompression, these MUST be concatenated\n  //   into a single octet string using the two octet delimiter of 0x3B, 0x20 (the ASCII\n  //   string \"; \").\n  if (('cookie' in headers) && (headers['cookie'] instanceof Array)) {\n    headers['cookie'] = headers['cookie'].join('; ');\n  }\n\n  return headers;\n};\n\n// When a `frame` arrives\nDecompressor.prototype._transform = function _transform(frame, encoding, done) {\n  // * and the collection process is already `_inProgress`, the frame is simply stored, except if\n  //   it's an illegal frame\n  if (this._inProgress) {\n    if ((frame.type !== 'CONTINUATION') || (frame.stream !== this._base.stream)) {\n      this._log.error('A series of HEADER frames were not continuous');\n      this.emit('error', 'PROTOCOL_ERROR');\n      return;\n    }\n    this._frames.push(frame);\n  }\n\n  // * and the collection process is not `_inProgress`, but the new frame's type is HEADERS or\n  //   PUSH_PROMISE, a new collection process begins\n  else if ((frame.type === 'HEADERS') || (frame.type === 'PUSH_PROMISE')) {\n    this._inProgress = true;\n    this._base = util._extend({}, frame);\n    this._frames = [frame];\n  }\n\n  // * otherwise, the frame is forwarded without taking any action\n  else {\n    this.push(frame);\n  }\n\n  // * When the frame signals that it's the last in the series, the header block chunks are\n  //   concatenated, the headers are decompressed, and a new frame gets pushed out with the\n  //   decompressed headers.\n  if (this._inProgress && (frame.flags.END_HEADERS || frame.flags.END_PUSH_PROMISE)) {\n    var buffer = concat(this._frames.map(function(frame) {\n      return frame.data;\n    }));\n    try {\n      var headers = this.decompress(buffer);\n    } catch(error) {\n      this._log.error({ err: error }, 'Header decompression error');\n      this.emit('error', 'COMPRESSION_ERROR');\n      return;\n    }\n    this.push(util._extend(this._base, { headers: headers }));\n    this._inProgress = false;\n  }\n\n  done();\n};\n\n// Helper functions\n// ================\n\n// Concatenate an array of buffers into a new buffer\nfunction concat(buffers) {\n  var size = 0;\n  for (var i = 0; i < buffers.length; i++) {\n    size += buffers[i].length;\n  }\n\n  var concatenated = new Buffer(size);\n  for (var cursor = 0, j = 0; j < buffers.length; cursor += buffers[j].length, j++) {\n    buffers[j].copy(concatenated, cursor);\n  }\n\n  return concatenated;\n}\n\n// Cut `buffer` into chunks not larger than `size`\nfunction cut(buffer, size) {\n  var chunks = [];\n  var cursor = 0;\n  do {\n    var chunkSize = Math.min(size, buffer.length - cursor);\n    chunks.push(buffer.slice(cursor, cursor + chunkSize));\n    cursor += chunkSize;\n  } while(cursor < buffer.length);\n  return chunks;\n}\n\nfunction trim(string) {\n  return string.trim();\n}\n","/home/travis/build/npmtest/node-npmtest-http2/node_modules/http2/lib/protocol/connection.js":"var assert = require('assert');\n\n// The Connection class\n// ====================\n\n// The Connection class manages HTTP/2 connections. Each instance corresponds to one transport\n// stream (TCP stream). It operates by sending and receiving frames and is implemented as a\n// [Flow](flow.html) subclass.\n\nvar Flow = require('./flow').Flow;\n\nexports.Connection = Connection;\n\n// Public API\n// ----------\n\n// * **new Connection(log, firstStreamId, settings)**: create a new Connection\n//\n// * **Event: 'error' (type)**: signals a connection level error made by the other end\n//\n// * **Event: 'peerError' (type)**: signals the receipt of a GOAWAY frame that contains an error\n//   code other than NO_ERROR\n//\n// * **Event: 'stream' (stream)**: signals that there's an incoming stream\n//\n// * **createStream(): stream**: initiate a new stream\n//\n// * **set(settings, callback)**: change the value of one or more settings according to the\n//   key-value pairs of `settings`. The callback is called after the peer acknowledged the changes.\n//\n// * **ping([callback])**: send a ping and call callback when the answer arrives\n//\n// * **close([error])**: close the stream with an error code\n\n// Constructor\n// -----------\n\n// The main aspects of managing the connection are:\nfunction Connection(log, firstStreamId, settings) {\n  // * initializing the base class\n  Flow.call(this, 0);\n\n  // * logging: every method uses the common logger object\n  this._log = log.child({ component: 'connection' });\n\n  // * stream management\n  this._initializeStreamManagement(firstStreamId);\n\n  // * lifecycle management\n  this._initializeLifecycleManagement();\n\n  // * flow control\n  this._initializeFlowControl();\n\n  // * settings management\n  this._initializeSettingsManagement(settings);\n\n  // * multiplexing\n  this._initializeMultiplexing();\n}\nConnection.prototype = Object.create(Flow.prototype, { constructor: { value: Connection } });\n\n// Overview\n// --------\n\n//              |    ^             |    ^\n//              v    |             v    |\n//         +--------------+   +--------------+\n//     +---|   stream1    |---|   stream2    |----      ....      ---+\n//     |   | +----------+ |   | +----------+ |                       |\n//     |   | | stream1. | |   | | stream2. | |                       |\n//     |   +-| upstream |-+   +-| upstream |-+                       |\n//     |     +----------+       +----------+                         |\n//     |       |     ^             |     ^                           |\n//     |       v     |             v     |                           |\n//     |       +-----+-------------+-----+--------      ....         |\n//     |       ^     |             |     |                           |\n//     |       |     v             |     |                           |\n//     |   +--------------+        |     |                           |\n//     |   |   stream0    |        |     |                           |\n//     |   |  connection  |        |     |                           |\n//     |   |  management  |     multiplexing                         |\n//     |   +--------------+     flow control                         |\n//     |                           |     ^                           |\n//     |                   _read() |     | _write()                  |\n//     |                           v     |                           |\n//     |                +------------+ +-----------+                 |\n//     |                |output queue| |input queue|                 |\n//     +----------------+------------+-+-----------+-----------------+\n//                                 |     ^\n//                          read() |     | write()\n//                                 v     |\n\n// Stream management\n// -----------------\n\nvar Stream  = require('./stream').Stream;\n\n// Initialization:\nConnection.prototype._initializeStreamManagement = function _initializeStreamManagement(firstStreamId) {\n  // * streams are stored in two data structures:\n  //   * `_streamIds` is an id -> stream map of the streams that are allowed to receive frames.\n  //   * `_streamPriorities` is a priority -> [stream] map of stream that allowed to send frames.\n  this._streamIds = [];\n  this._streamPriorities = [];\n\n  // * The next outbound stream ID and the last inbound stream id\n  this._nextStreamId = firstStreamId;\n  this._lastIncomingStream = 0;\n\n  // * Calling `_writeControlFrame` when there's an incoming stream with 0 as stream ID\n  this._streamIds[0] = { upstream: { write: this._writeControlFrame.bind(this) } };\n\n  // * By default, the number of concurrent outbound streams is not limited. The `_streamLimit` can\n  //   be set by the SETTINGS_MAX_CONCURRENT_STREAMS setting.\n  this._streamSlotsFree = Infinity;\n  this._streamLimit = Infinity;\n  this.on('RECEIVING_SETTINGS_MAX_CONCURRENT_STREAMS', this._updateStreamLimit);\n};\n\n// `_writeControlFrame` is called when there's an incoming frame in the `_control` stream. It\n// broadcasts the message by creating an event on it.\nConnection.prototype._writeControlFrame = function _writeControlFrame(frame) {\n  if ((frame.type === 'SETTINGS') || (frame.type === 'PING') ||\n      (frame.type === 'GOAWAY') || (frame.type === 'WINDOW_UPDATE') ||\n      (frame.type === 'ALTSVC')) {\n    this._log.debug({ frame: frame }, 'Receiving connection level frame');\n    this.emit(frame.type, frame);\n  } else {\n    this._log.error({ frame: frame }, 'Invalid connection level frame');\n    this.emit('error', 'PROTOCOL_ERROR');\n  }\n};\n\n// Methods to manage the stream slot pool:\nConnection.prototype._updateStreamLimit = function _updateStreamLimit(newStreamLimit) {\n  var wakeup = (this._streamSlotsFree === 0) && (newStreamLimit > this._streamLimit);\n  this._streamSlotsFree += newStreamLimit - this._streamLimit;\n  this._streamLimit = newStreamLimit;\n  if (wakeup) {\n    this.emit('wakeup');\n  }\n};\n\nConnection.prototype._changeStreamCount = function _changeStreamCount(change) {\n  if (change) {\n    this._log.trace({ free: this._streamSlotsFree, change: change },\n                    'Changing active stream count.');\n    var wakeup = (this._streamSlotsFree === 0) && (change < 0);\n    this._streamSlotsFree -= change;\n    if (wakeup) {\n      this.emit('wakeup');\n    }\n  }\n};\n\n// Creating a new *inbound or outbound* stream with the given `id` (which is undefined in case of\n// an outbound stream) consists of three steps:\n//\n// 1. var stream = new Stream(this._log, this);\n// 2. this._allocateId(stream, id);\n// 2. this._allocatePriority(stream);\n\n// Allocating an ID to a stream\nConnection.prototype._allocateId = function _allocateId(stream, id) {\n  // * initiated stream without definite ID\n  if (id === undefined) {\n    id = this._nextStreamId;\n    this._nextStreamId += 2;\n  }\n\n  // * incoming stream with a legitim ID (larger than any previous and different parity than ours)\n  else if ((id > this._lastIncomingStream) && ((id - this._nextStreamId) % 2 !== 0)) {\n    this._lastIncomingStream = id;\n  }\n\n  // * incoming stream with invalid ID\n  else {\n    this._log.error({ stream_id: id, lastIncomingStream: this._lastIncomingStream },\n                    'Invalid incoming stream ID.');\n    this.emit('error', 'PROTOCOL_ERROR');\n    return undefined;\n  }\n\n  assert(!(id in this._streamIds));\n\n  // * adding to `this._streamIds`\n  this._log.trace({ s: stream, stream_id: id }, 'Allocating ID for stream.');\n  this._streamIds[id] = stream;\n  stream.id = id;\n  this.emit('new_stream', stream, id);\n\n  // * forwarding connection errors from streams\n  stream.on('connectionError', this.emit.bind(this, 'error'));\n\n  return id;\n};\n\n// Allocating a priority to a stream, and managing priority changes\nConnection.prototype._allocatePriority = function _allocatePriority(stream) {\n  this._log.trace({ s: stream }, 'Allocating priority for stream.');\n  this._insert(stream, stream._priority);\n  stream.on('priority', this._reprioritize.bind(this, stream));\n  stream.upstream.on('readable', this.emit.bind(this, 'wakeup'));\n  this.emit('wakeup');\n};\n\nConnection.prototype._insert = function _insert(stream, priority) {\n  if (priority in this._streamPriorities) {\n    this._streamPriorities[priority].push(stream);\n  } else {\n    this._streamPriorities[priority] = [stream];\n  }\n};\n\nConnection.prototype._reprioritize = function _reprioritize(stream, priority) {\n  var bucket = this._streamPriorities[stream._priority];\n  var index = bucket.indexOf(stream);\n  assert(index !== -1);\n  bucket.splice(index, 1);\n  if (bucket.length === 0) {\n    delete this._streamPriorities[stream._priority];\n  }\n\n  this._insert(stream, priority);\n};\n\n// Creating an *inbound* stream with the given ID. It is called when there's an incoming frame to\n// a previously nonexistent stream.\nConnection.prototype._createIncomingStream = function _createIncomingStream(id) {\n  this._log.debug({ stream_id: id }, 'New incoming stream.');\n\n  var stream = new Stream(this._log, this);\n  this._allocateId(stream, id);\n  this._allocatePriority(stream);\n  this.emit('stream', stream, id);\n\n  return stream;\n};\n\n// Creating an *outbound* stream\nConnection.prototype.createStream = function createStream() {\n  this._log.trace('Creating new outbound stream.');\n\n  // * Receiving is enabled immediately, and an ID gets assigned to the stream\n  var stream = new Stream(this._log, this);\n  this._allocatePriority(stream);\n\n  return stream;\n};\n\n// Multiplexing\n// ------------\n\nConnection.prototype._initializeMultiplexing = function _initializeMultiplexing() {\n  this.on('window_update', this.emit.bind(this, 'wakeup'));\n  this._sendScheduled = false;\n  this._firstFrameReceived = false;\n};\n\n// The `_send` method is a virtual method of the [Flow class](flow.html) that has to be implemented\n// by child classes. It reads frames from streams and pushes them to the output buffer.\nConnection.prototype._send = function _send(immediate) {\n  // * Do not do anything if the connection is already closed\n  if (this._closed) {\n    return;\n  }\n\n  // * Collapsing multiple calls in a turn into a single deferred call\n  if (immediate) {\n    this._sendScheduled = false;\n  } else {\n    if (!this._sendScheduled) {\n      this._sendScheduled = true;\n      setImmediate(this._send.bind(this, true));\n    }\n    return;\n  }\n\n  this._log.trace('Starting forwarding frames from streams.');\n\n  // * Looping through priority `bucket`s in priority order.\npriority_loop:\n  for (var priority in this._streamPriorities) {\n    var bucket = this._streamPriorities[priority];\n    var nextBucket = [];\n\n    // * Forwarding frames from buckets with round-robin scheduling.\n    //   1. pulling out frame\n    //   2. if there's no frame, skip this stream\n    //   3. if forwarding this frame would make `streamCount` greater than `streamLimit`, skip\n    //      this stream\n    //   4. adding stream to the bucket of the next round\n    //   5. assigning an ID to the frame (allocating an ID to the stream if there isn't already)\n    //   6. if forwarding a PUSH_PROMISE, allocate ID to the promised stream\n    //   7. forwarding the frame, changing `streamCount` as appropriate\n    //   8. stepping to the next stream if there's still more frame needed in the output buffer\n    //   9. switching to the bucket of the next round\n    while (bucket.length > 0) {\n      for (var index = 0; index < bucket.length; index++) {\n        var stream = bucket[index];\n        var frame = stream.upstream.read((this._window > 0) ? this._window : -1);\n\n        if (!frame) {\n          continue;\n        } else if (frame.count_change > this._streamSlotsFree) {\n          stream.upstream.unshift(frame);\n          continue;\n        }\n\n        nextBucket.push(stream);\n\n        if (frame.stream === undefined) {\n          frame.stream = stream.id || this._allocateId(stream);\n        }\n\n        if (frame.type === 'PUSH_PROMISE') {\n          this._allocatePriority(frame.promised_stream);\n          frame.promised_stream = this._allocateId(frame.promised_stream);\n        }\n\n        this._log.trace({ s: stream, frame: frame }, 'Forwarding outgoing frame');\n        var moreNeeded = this.push(frame);\n        this._changeStreamCount(frame.count_change);\n\n        assert(moreNeeded !== null); // The frame shouldn't be unforwarded\n        if (moreNeeded === false) {\n          break priority_loop;\n        }\n      }\n\n      bucket = nextBucket;\n      nextBucket = [];\n    }\n  }\n\n  // * if we couldn't forward any frame, then sleep until window update, or some other wakeup event\n  if (moreNeeded === undefined) {\n    this.once('wakeup', this._send.bind(this));\n  }\n\n  this._log.trace({ moreNeeded: moreNeeded }, 'Stopping forwarding frames from streams.');\n};\n\n// The `_receive` method is another virtual method of the [Flow class](flow.html) that has to be\n// implemented by child classes. It forwards the given frame to the appropriate stream:\nConnection.prototype._receive = function _receive(frame, done) {\n  this._log.trace({ frame: frame }, 'Forwarding incoming frame');\n\n  // * first frame needs to be checked by the `_onFirstFrameReceived` method\n  if (!this._firstFrameReceived) {\n    this._firstFrameReceived = true;\n    this._onFirstFrameReceived(frame);\n  }\n\n  // Do some sanity checking here before we create a stream\n  if ((frame.type == 'SETTINGS' ||\n       frame.type == 'PING' ||\n       frame.type == 'GOAWAY') &&\n      frame.stream != 0) {\n    // Got connection-level frame on a stream - EEP!\n    this.close('PROTOCOL_ERROR');\n    return;\n  } else if ((frame.type == 'DATA' ||\n              frame.type == 'HEADERS' ||\n              frame.type == 'PRIORITY' ||\n              frame.type == 'RST_STREAM' ||\n              frame.type == 'PUSH_PROMISE' ||\n              frame.type == 'CONTINUATION') &&\n             frame.stream == 0) {\n    // Got stream-level frame on connection - EEP!\n    this.close('PROTOCOL_ERROR');\n    return;\n  }\n  // WINDOW_UPDATE can be on either stream or connection\n\n  // * gets the appropriate stream from the stream registry\n  var stream = this._streamIds[frame.stream];\n\n  // * or creates one if it's not in `this.streams`\n  if (!stream) {\n    stream = this._createIncomingStream(frame.stream);\n  }\n\n  // * in case of PUSH_PROMISE, replaces the promised stream id with a new incoming stream\n  if (frame.type === 'PUSH_PROMISE') {\n    frame.promised_stream = this._createIncomingStream(frame.promised_stream);\n  }\n\n  frame.count_change = this._changeStreamCount.bind(this);\n\n  // * and writes it to the `stream`'s `upstream`\n  stream.upstream.write(frame);\n\n  done();\n};\n\n// Settings management\n// -------------------\n\nvar defaultSettings = {\n};\n\n// Settings management initialization:\nConnection.prototype._initializeSettingsManagement = function _initializeSettingsManagement(settings) {\n  // * Setting up the callback queue for setting acknowledgements\n  this._settingsAckCallbacks = [];\n\n  // * Sending the initial settings.\n  this._log.debug({ settings: settings },\n                  'Sending the first SETTINGS frame as part of the connection header.');\n  this.set(settings || defaultSettings);\n\n  // * Forwarding SETTINGS frames to the `_receiveSettings` method\n  this.on('SETTINGS', this._receiveSettings);\n  this.on('RECEIVING_SETTINGS_MAX_FRAME_SIZE', this._sanityCheckMaxFrameSize);\n};\n\n// * Checking that the first frame the other endpoint sends is SETTINGS\nConnection.prototype._onFirstFrameReceived = function _onFirstFrameReceived(frame) {\n  if ((frame.stream === 0) && (frame.type === 'SETTINGS')) {\n    this._log.debug('Receiving the first SETTINGS frame as part of the connection header.');\n  } else {\n    this._log.fatal({ frame: frame }, 'Invalid connection header: first frame is not SETTINGS.');\n    this.emit('error', 'PROTOCOL_ERROR');\n  }\n};\n\n// Handling of incoming SETTINGS frames.\nConnection.prototype._receiveSettings = function _receiveSettings(frame) {\n  // * If it's an ACK, call the appropriate callback\n  if (frame.flags.ACK) {\n    var callback = this._settingsAckCallbacks.shift();\n    if (callback) {\n      callback();\n    }\n  }\n\n  // * If it's a setting change request, then send an ACK and change the appropriate settings\n  else {\n    if (!this._closed) {\n      this.push({\n        type: 'SETTINGS',\n        flags: { ACK: true },\n        stream: 0,\n        settings: {}\n      });\n    }\n    for (var name in frame.settings) {\n      this.emit('RECEIVING_' + name, frame.settings[name]);\n    }\n  }\n};\n\nConnection.prototype._sanityCheckMaxFrameSize = function _sanityCheckMaxFrameSize(value) {\n  if ((value < 0x4000) || (value >= 0x01000000)) {\n    this._log.fatal('Received invalid value for max frame size: ' + value);\n    this.emit('error');\n  }\n};\n\n// Changing one or more settings value and sending out a SETTINGS frame\nConnection.prototype.set = function set(settings, callback) {\n  // * Calling the callback and emitting event when the change is acknowledges\n  var self = this;\n  this._settingsAckCallbacks.push(function() {\n    for (var name in settings) {\n      self.emit('ACKNOWLEDGED_' + name, settings[name]);\n    }\n    if (callback) {\n      callback();\n    }\n  });\n\n  // * Sending out the SETTINGS frame\n  this.push({\n    type: 'SETTINGS',\n    flags: { ACK: false },\n    stream: 0,\n    settings: settings\n  });\n  for (var name in settings) {\n    this.emit('SENDING_' + name, settings[name]);\n  }\n};\n\n// Lifecycle management\n// --------------------\n\n// The main responsibilities of lifecycle management code:\n//\n// * keeping the connection alive by\n//   * sending PINGs when the connection is idle\n//   * answering PINGs\n// * ending the connection\n\nConnection.prototype._initializeLifecycleManagement = function _initializeLifecycleManagement() {\n  this._pings = {};\n  this.on('PING', this._receivePing);\n  this.on('GOAWAY', this._receiveGoaway);\n  this._closed = false;\n};\n\n// Generating a string of length 16 with random hexadecimal digits\nConnection.prototype._generatePingId = function _generatePingId() {\n  do {\n    var id = '';\n    for (var i = 0; i < 16; i++) {\n      id += Math.floor(Math.random()*16).toString(16);\n    }\n  } while(id in this._pings);\n  return id;\n};\n\n// Sending a ping and calling `callback` when the answer arrives\nConnection.prototype.ping = function ping(callback) {\n  var id = this._generatePingId();\n  var data = new Buffer(id, 'hex');\n  this._pings[id] = callback;\n\n  this._log.debug({ data: data }, 'Sending PING.');\n  this.push({\n    type: 'PING',\n    flags: {\n      ACK: false\n    },\n    stream: 0,\n    data: data\n  });\n};\n\n// Answering pings\nConnection.prototype._receivePing = function _receivePing(frame) {\n  if (frame.flags.ACK) {\n    var id = frame.data.toString('hex');\n    if (id in this._pings) {\n      this._log.debug({ data: frame.data }, 'Receiving answer for a PING.');\n      var callback = this._pings[id];\n      if (callback) {\n        callback();\n      }\n      delete this._pings[id];\n    } else {\n      this._log.warn({ data: frame.data }, 'Unsolicited PING answer.');\n    }\n\n  } else {\n    this._log.debug({ data: frame.data }, 'Answering PING.');\n    this.push({\n      type: 'PING',\n      flags: {\n        ACK: true\n      },\n      stream: 0,\n      data: frame.data\n    });\n  }\n};\n\n// Terminating the connection\nConnection.prototype.close = function close(error) {\n  if (this._closed) {\n    this._log.warn('Trying to close an already closed connection');\n    return;\n  }\n\n  this._log.debug({ error: error }, 'Closing the connection');\n  this.push({\n    type: 'GOAWAY',\n    flags: {},\n    stream: 0,\n    last_stream: this._lastIncomingStream,\n    error: error || 'NO_ERROR'\n  });\n  this.push(null);\n  this._closed = true;\n};\n\nConnection.prototype._receiveGoaway = function _receiveGoaway(frame) {\n  this._log.debug({ error: frame.error }, 'Other end closed the connection');\n  this.push(null);\n  this._closed = true;\n  if (frame.error !== 'NO_ERROR') {\n    this.emit('peerError', frame.error);\n  }\n};\n\n// Flow control\n// ------------\n\nConnection.prototype._initializeFlowControl = function _initializeFlowControl() {\n  // Handling of initial window size of individual streams.\n  this._initialStreamWindowSize = INITIAL_STREAM_WINDOW_SIZE;\n  this.on('new_stream', function(stream) {\n    stream.upstream.setInitialWindow(this._initialStreamWindowSize);\n  });\n  this.on('RECEIVING_SETTINGS_INITIAL_WINDOW_SIZE', this._setInitialStreamWindowSize);\n  this._streamIds[0].upstream.setInitialWindow = function noop() {};\n};\n\n// The initial connection flow control window is 65535 bytes.\nvar INITIAL_STREAM_WINDOW_SIZE = 65535;\n\n// A SETTINGS frame can alter the initial flow control window size for all current streams. When the\n// value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust the window size of all\n// stream by calling the `setInitialStreamWindowSize` method. The window size has to be modified by\n// the difference between the new value and the old value.\nConnection.prototype._setInitialStreamWindowSize = function _setInitialStreamWindowSize(size) {\n  if ((this._initialStreamWindowSize === Infinity) && (size !== Infinity)) {\n    this._log.error('Trying to manipulate initial flow control window size after flow control was turned off.');\n    this.emit('error', 'FLOW_CONTROL_ERROR');\n  } else {\n    this._log.debug({ size: size }, 'Changing stream initial window size.');\n    this._initialStreamWindowSize = size;\n    this._streamIds.forEach(function(stream) {\n      stream.upstream.setInitialWindow(size);\n    });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-http2/node_modules/http2/lib/protocol/flow.js":"var assert = require('assert');\n\n// The Flow class\n// ==============\n\n// Flow is a [Duplex stream][1] subclass which implements HTTP/2 flow control. It is designed to be\n// subclassed by [Connection](connection.html) and the `upstream` component of [Stream](stream.html).\n// [1]: https://nodejs.org/api/stream.html#stream_class_stream_duplex\n\nvar Duplex  = require('stream').Duplex;\n\nexports.Flow = Flow;\n\n// Public API\n// ----------\n\n// * **Event: 'error' (type)**: signals an error\n//\n// * **setInitialWindow(size)**: the initial flow control window size can be changed *any time*\n//   ([as described in the standard][1]) using this method\n//\n// [1]: https://tools.ietf.org/html/rfc7540#section-6.9.2\n\n// API for child classes\n// ---------------------\n\n// * **new Flow([flowControlId])**: creating a new flow that will listen for WINDOW_UPDATES frames\n//   with the given `flowControlId` (or every update frame if not given)\n//\n// * **_send()**: called when more frames should be pushed. The child class is expected to override\n//   this (instead of the `_read` method of the Duplex class).\n//\n// * **_receive(frame, readyCallback)**: called when there's an incoming frame. The child class is\n//   expected to override this (instead of the `_write` method of the Duplex class).\n//\n// * **push(frame): bool**: schedules `frame` for sending.\n//\n//   Returns `true` if it needs more frames in the output queue, `false` if the output queue is\n//   full, and `null` if did not push the frame into the output queue (instead, it pushed it into\n//   the flow control queue).\n//\n// * **read(limit): frame**: like the regular `read`, but the 'flow control size' (0 for non-DATA\n//   frames, length of the payload for DATA frames) of the returned frame will be under `limit`.\n//   Small exception: pass -1 as `limit` if the max. flow control size is 0. `read(0)` means the\n//   same thing as [in the original API](https://nodejs.org/api/stream.html#stream_stream_read_0).\n//\n// * **getLastQueuedFrame(): frame**: returns the last frame in output buffers\n//\n// * **_log**: the Flow class uses the `_log` object of the parent\n\n// Constructor\n// -----------\n\n// When a HTTP/2.0 connection is first established, new streams are created with an initial flow\n// control window size of 65535 bytes.\nvar INITIAL_WINDOW_SIZE = 65535;\n\n// `flowControlId` is needed if only specific WINDOW_UPDATEs should be watched.\nfunction Flow(flowControlId) {\n  Duplex.call(this, { objectMode: true });\n\n  this._window = this._initialWindow = INITIAL_WINDOW_SIZE;\n  this._flowControlId = flowControlId;\n  this._queue = [];\n  this._ended = false;\n  this._received = 0;\n  this._blocked = false;\n}\nFlow.prototype = Object.create(Duplex.prototype, { constructor: { value: Flow } });\n\n// Incoming frames\n// ---------------\n\n// `_receive` is called when there's an incoming frame.\nFlow.prototype._receive = function _receive(frame, callback) {\n  throw new Error('The _receive(frame, callback) method has to be overridden by the child class!');\n};\n\n// `_receive` is called by `_write` which in turn is [called by Duplex][1] when someone `write()`s\n// to the flow. It emits the 'receiving' event and notifies the window size tracking code if the\n// incoming frame is a WINDOW_UPDATE.\n// [1]: https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback_1\nFlow.prototype._write = function _write(frame, encoding, callback) {\n  var sentToUs = (this._flowControlId === undefined) || (frame.stream === this._flowControlId);\n\n  if (sentToUs && (frame.flags.END_STREAM || (frame.type === 'RST_STREAM'))) {\n    this._ended = true;\n  }\n\n  if ((frame.type === 'DATA') && (frame.data.length > 0)) {\n    this._receive(frame, function() {\n      this._received += frame.data.length;\n      if (!this._restoreWindowTimer) {\n        this._restoreWindowTimer = setImmediate(this._restoreWindow.bind(this));\n      }\n      callback();\n    }.bind(this));\n  }\n\n  else {\n    this._receive(frame, callback);\n  }\n\n  if (sentToUs && (frame.type === 'WINDOW_UPDATE')) {\n    this._updateWindow(frame);\n  }\n};\n\n// `_restoreWindow` basically acknowledges the DATA frames received since it's last call. It sends\n// a WINDOW_UPDATE that restores the flow control window of the remote end.\n// TODO: push this directly into the output queue. No need to wait for DATA frames in the queue.\nFlow.prototype._restoreWindow = function _restoreWindow() {\n  delete this._restoreWindowTimer;\n  if (!this._ended && (this._received > 0)) {\n    this.push({\n      type: 'WINDOW_UPDATE',\n      flags: {},\n      stream: this._flowControlId,\n      window_size: this._received\n    });\n    this._received = 0;\n  }\n};\n\n// Outgoing frames - sending procedure\n// -----------------------------------\n\n//                                         flow\n//                +-------------------------------------------------+\n//                |                                                 |\n//                +--------+           +---------+                  |\n//        read()  | output |  _read()  | flow    |  _send()         |\n//     <----------|        |<----------| control |<-------------    |\n//                | buffer |           | buffer  |                  |\n//                +--------+           +---------+                  |\n//                | input  |                                        |\n//     ---------->|        |----------------------------------->    |\n//       write()  | buffer |  _write()              _receive()      |\n//                +--------+                                        |\n//                |                                                 |\n//                +-------------------------------------------------+\n\n// `_send` is called when more frames should be pushed to the output buffer.\nFlow.prototype._send = function _send() {\n  throw new Error('The _send() method has to be overridden by the child class!');\n};\n\n// `_send` is called by `_read` which is in turn [called by Duplex][1] when it wants to have more\n// items in the output queue.\n// [1]: https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback_1\nFlow.prototype._read = function _read() {\n  // * if the flow control queue is empty, then let the user push more frames\n  if (this._queue.length === 0) {\n    this._send();\n  }\n\n  // * if there are items in the flow control queue, then let's put them into the output queue (to\n  //   the extent it is possible with respect to the window size and output queue feedback)\n  else if (this._window > 0) {\n    this._blocked = false;\n    this._readableState.sync = true; // to avoid reentrant calls\n    do {\n      var moreNeeded = this._push(this._queue[0]);\n      if (moreNeeded !== null) {\n        this._queue.shift();\n      }\n    } while (moreNeeded && (this._queue.length > 0));\n    this._readableState.sync = false;\n\n    assert((!moreNeeded) ||                              // * output queue is full\n           (this._queue.length === 0) ||                         // * flow control queue is empty\n           (!this._window && (this._queue[0].type === 'DATA'))); // * waiting for window update\n  }\n\n  // * otherwise, come back when the flow control window is positive\n  else if (!this._blocked) {\n    this._parentPush({\n      type: 'BLOCKED',\n      flags: {},\n      stream: this._flowControlId\n    });\n    this.once('window_update', this._read);\n    this._blocked = true;\n  }\n};\n\nvar MAX_PAYLOAD_SIZE = 4096; // Must not be greater than MAX_HTTP_PAYLOAD_SIZE which is 16383\n\n// `read(limit)` is like the `read` of the Readable class, but it guarantess that the 'flow control\n// size' (0 for non-DATA frames, length of the payload for DATA frames) of the returned frame will\n// be under `limit`.\nFlow.prototype.read = function read(limit) {\n  if (limit === 0) {\n    return Duplex.prototype.read.call(this, 0);\n  } else if (limit === -1) {\n    limit = 0;\n  } else if ((limit === undefined) || (limit > MAX_PAYLOAD_SIZE)) {\n    limit = MAX_PAYLOAD_SIZE;\n  }\n\n  // * Looking at the first frame in the queue without pulling it out if possible.\n  var frame = this._readableState.buffer[0];\n  if (!frame && !this._readableState.ended) {\n    this._read();\n    frame = this._readableState.buffer[0];\n  }\n\n  if (frame && (frame.type === 'DATA')) {\n    // * If the frame is DATA, then there's two special cases:\n    //   * if the limit is 0, we shouldn't return anything\n    //   * if the size of the frame is larger than limit, then the frame should be split\n    if (limit === 0) {\n      return Duplex.prototype.read.call(this, 0);\n    }\n\n    else if (frame.data.length > limit) {\n      this._log.trace({ frame: frame, size: frame.data.length, forwardable: limit },\n        'Splitting out forwardable part of a DATA frame.');\n      this.unshift({\n        type: 'DATA',\n        flags: {},\n        stream: frame.stream,\n        data: frame.data.slice(0, limit)\n      });\n      frame.data = frame.data.slice(limit);\n    }\n  }\n\n  return Duplex.prototype.read.call(this);\n};\n\n// `_parentPush` pushes the given `frame` into the output queue\nFlow.prototype._parentPush = function _parentPush(frame) {\n  this._log.trace({ frame: frame }, 'Pushing frame into the output queue');\n\n  if (frame && (frame.type === 'DATA') && (this._window !== Infinity)) {\n    this._log.trace({ window: this._window, by: frame.data.length },\n                    'Decreasing flow control window size.');\n    this._window -= frame.data.length;\n    assert(this._window >= 0);\n  }\n\n  return Duplex.prototype.push.call(this, frame);\n};\n\n// `_push(frame)` pushes `frame` into the output queue and decreases the flow control window size.\n// It is capable of splitting DATA frames into smaller parts, if the window size is not enough to\n// push the whole frame. The return value is similar to `push` except that it returns `null` if it\n// did not push the whole frame to the output queue (but maybe it did push part of the frame).\nFlow.prototype._push = function _push(frame) {\n  var data = frame && (frame.type === 'DATA') && frame.data;\n  var maxFrameLength = (this._window < 16384) ? this._window : 16384;\n\n  if (!data || (data.length <= maxFrameLength)) {\n    return this._parentPush(frame);\n  }\n\n  else if (this._window <= 0) {\n    return null;\n  }\n\n  else {\n    this._log.trace({ frame: frame, size: frame.data.length, forwardable: this._window },\n                    'Splitting out forwardable part of a DATA frame.');\n    frame.data = data.slice(maxFrameLength);\n    this._parentPush({\n      type: 'DATA',\n      flags: {},\n      stream: frame.stream,\n      data: data.slice(0, maxFrameLength)\n    });\n    return null;\n  }\n};\n\n// Push `frame` into the flow control queue, or if it's empty, then directly into the output queue\nFlow.prototype.push = function push(frame) {\n  if (frame === null) {\n    this._log.debug('Enqueueing outgoing End Of Stream');\n  } else {\n    this._log.debug({ frame: frame }, 'Enqueueing outgoing frame');\n  }\n\n  var moreNeeded = null;\n  if (this._queue.length === 0) {\n    moreNeeded = this._push(frame);\n  }\n\n  if (moreNeeded === null) {\n    this._queue.push(frame);\n  }\n\n  return moreNeeded;\n};\n\n// `getLastQueuedFrame` returns the last frame in output buffers. This is primarily used by the\n// [Stream](stream.html) class to mark the last frame with END_STREAM flag.\nFlow.prototype.getLastQueuedFrame = function getLastQueuedFrame() {\n  var readableQueue = this._readableState.buffer;\n  return this._queue[this._queue.length - 1] || readableQueue[readableQueue.length - 1];\n};\n\n// Outgoing frames - managing the window size\n// ------------------------------------------\n\n// Flow control window size is manipulated using the `_increaseWindow` method.\n//\n// * Invoking it with `Infinite` means turning off flow control. Flow control cannot be enabled\n//   again once disabled. Any attempt to re-enable flow control MUST be rejected with a\n//   FLOW_CONTROL_ERROR error code.\n// * A sender MUST NOT allow a flow control window to exceed 2^31 - 1 bytes. The action taken\n//   depends on it being a stream or the connection itself.\n\nvar WINDOW_SIZE_LIMIT = Math.pow(2, 31) - 1;\n\nFlow.prototype._increaseWindow = function _increaseWindow(size) {\n  if ((this._window === Infinity) && (size !== Infinity)) {\n    this._log.error('Trying to increase flow control window after flow control was turned off.');\n    this.emit('error', 'FLOW_CONTROL_ERROR');\n  } else {\n    this._log.trace({ window: this._window, by: size }, 'Increasing flow control window size.');\n    this._window += size;\n    if ((this._window !== Infinity) && (this._window > WINDOW_SIZE_LIMIT)) {\n      this._log.error('Flow control window grew too large.');\n      this.emit('error', 'FLOW_CONTROL_ERROR');\n    } else {\n      if (size != 0) {\n        this.emit('window_update');\n      }\n    }\n  }\n};\n\n// The `_updateWindow` method gets called every time there's an incoming WINDOW_UPDATE frame. It\n// modifies the flow control window:\n//\n// * Flow control can be disabled for an individual stream by sending a WINDOW_UPDATE with the\n//   END_FLOW_CONTROL flag set. The payload of a WINDOW_UPDATE frame that has the END_FLOW_CONTROL\n//   flag set is ignored.\n// * A sender that receives a WINDOW_UPDATE frame updates the corresponding window by the amount\n//   specified in the frame.\nFlow.prototype._updateWindow = function _updateWindow(frame) {\n  this._increaseWindow(frame.flags.END_FLOW_CONTROL ? Infinity : frame.window_size);\n};\n\n// A SETTINGS frame can alter the initial flow control window size for all current streams. When the\n// value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust the size of all stream by\n// calling the `setInitialWindow` method. The window size has to be modified by the difference\n// between the new value and the old value.\nFlow.prototype.setInitialWindow = function setInitialWindow(initialWindow) {\n  this._increaseWindow(initialWindow - this._initialWindow);\n  this._initialWindow = initialWindow;\n};\n","/home/travis/build/npmtest/node-npmtest-http2/node_modules/http2/lib/protocol/stream.js":"var assert = require('assert');\n\n// The Stream class\n// ================\n\n// Stream is a [Duplex stream](https://nodejs.org/api/stream.html#stream_class_stream_duplex)\n// subclass that implements the [HTTP/2 Stream](https://tools.ietf.org/html/rfc7540#section-5)\n// concept. It has two 'sides': one that is used by the user to send/receive data (the `stream`\n// object itself) and one that is used by a Connection to read/write frames to/from the other peer\n// (`stream.upstream`).\n\nvar Duplex = require('stream').Duplex;\n\nexports.Stream = Stream;\n\n// Public API\n// ----------\n\n// * **new Stream(log, connection)**: create a new Stream\n//\n// * **Event: 'headers' (headers)**: signals incoming headers\n//\n// * **Event: 'promise' (stream, headers)**: signals an incoming push promise\n//\n// * **Event: 'priority' (priority)**: signals a priority change. `priority` is a number between 0\n//     (highest priority) and 2^31-1 (lowest priority). Default value is 2^30.\n//\n// * **Event: 'error' (type)**: signals an error\n//\n// * **headers(headers)**: send headers\n//\n// * **promise(headers): Stream**: promise a stream\n//\n// * **priority(priority)**: set the priority of the stream. Priority can be changed by the peer\n//   too, but once it is set locally, it can not be changed remotely.\n//\n// * **reset(error)**: reset the stream with an error code\n//\n// * **upstream**: a [Flow](flow.js) that is used by the parent connection to write/read frames\n//   that are to be sent/arrived to/from the peer and are related to this stream.\n//\n// Headers are always in the [regular node.js header format][1].\n// [1]: https://nodejs.org/api/http.html#http_message_headers\n\n// Constructor\n// -----------\n\n// The main aspects of managing the stream are:\nfunction Stream(log, connection) {\n  Duplex.call(this);\n\n  // * logging\n  this._log = log.child({ component: 'stream', s: this });\n\n  // * receiving and sending stream management commands\n  this._initializeManagement();\n\n  // * sending and receiving frames to/from the upstream connection\n  this._initializeDataFlow();\n\n  // * maintaining the state of the stream (idle, open, closed, etc.) and error detection\n  this._initializeState();\n\n  this.connection = connection;\n}\n\nStream.prototype = Object.create(Duplex.prototype, { constructor: { value: Stream } });\n\n// Managing the stream\n// -------------------\n\n// the default stream priority is 2^30\nvar DEFAULT_PRIORITY = Math.pow(2, 30);\nvar MAX_PRIORITY = Math.pow(2, 31) - 1;\n\n// PUSH_PROMISE and HEADERS are forwarded to the user through events.\nStream.prototype._initializeManagement = function _initializeManagement() {\n  this._resetSent = false;\n  this._priority = DEFAULT_PRIORITY;\n  this._letPeerPrioritize = true;\n};\n\nStream.prototype.promise = function promise(headers) {\n  var stream = new Stream(this._log, this.connection);\n  stream._priority = Math.min(this._priority + 1, MAX_PRIORITY);\n  this._pushUpstream({\n    type: 'PUSH_PROMISE',\n    flags: {},\n    stream: this.id,\n    promised_stream: stream,\n    headers: headers\n  });\n  return stream;\n};\n\nStream.prototype._onPromise = function _onPromise(frame) {\n  this.emit('promise', frame.promised_stream, frame.headers);\n};\n\nStream.prototype.headers = function headers(headers) {\n  this._pushUpstream({\n    type: 'HEADERS',\n    flags: {},\n    stream: this.id,\n    headers: headers\n  });\n};\n\nStream.prototype._onHeaders = function _onHeaders(frame) {\n  if (frame.priority !== undefined) {\n    this.priority(frame.priority, true);\n  }\n  this.emit('headers', frame.headers);\n};\n\nStream.prototype.priority = function priority(priority, peer) {\n  if ((peer && this._letPeerPrioritize) || !peer) {\n    if (!peer) {\n      this._letPeerPrioritize = false;\n\n      var lastFrame = this.upstream.getLastQueuedFrame();\n      if (lastFrame && ((lastFrame.type === 'HEADERS') || (lastFrame.type === 'PRIORITY'))) {\n        lastFrame.priority = priority;\n      } else {\n        this._pushUpstream({\n          type: 'PRIORITY',\n          flags: {},\n          stream: this.id,\n          priority: priority\n        });\n      }\n    }\n\n    this._log.debug({ priority: priority }, 'Changing priority');\n    this.emit('priority', priority);\n    this._priority = priority;\n  }\n};\n\nStream.prototype._onPriority = function _onPriority(frame) {\n  this.priority(frame.priority, true);\n};\n\n// Resetting the stream. Normally, an endpoint SHOULD NOT send more than one RST_STREAM frame for\n// any stream.\nStream.prototype.reset = function reset(error) {\n  if (!this._resetSent) {\n    this._resetSent = true;\n    this._pushUpstream({\n      type: 'RST_STREAM',\n      flags: {},\n      stream: this.id,\n      error: error\n    });\n  }\n};\n\n// Specify an alternate service for the origin of this stream\nStream.prototype.altsvc = function altsvc(host, port, protocolID, maxAge, origin) {\n    var stream;\n    if (origin) {\n        stream = 0;\n    } else {\n        stream = this.id;\n    }\n    this._pushUpstream({\n        type: 'ALTSVC',\n        flags: {},\n        stream: stream,\n        host: host,\n        port: port,\n        protocolID: protocolID,\n        origin: origin,\n        maxAge: maxAge\n    });\n};\n\n// Data flow\n// ---------\n\n// The incoming and the generated outgoing frames are received/transmitted on the `this.upstream`\n// [Flow](flow.html). The [Connection](connection.html) object instantiating the stream will read\n// and write frames to/from it. The stream itself is a regular [Duplex stream][1], and is used by\n// the user to write or read the body of the request.\n// [1]: https://nodejs.org/api/stream.html#stream_class_stream_duplex\n\n//     upstream side                  stream                  user side\n//\n//                    +------------------------------------+\n//                    |                                    |\n//                    +------------------+                 |\n//                    |     upstream     |                 |\n//                    |                  |                 |\n//                    +--+               |              +--|\n//            read()  |  |  _send()      |    _write()  |  |  write(buf)\n//     <--------------|B |<--------------|--------------| B|<------------\n//                    |  |               |              |  |\n//            frames  +--+               |              +--|  buffers\n//                    |  |               |              |  |\n//     -------------->|B |---------------|------------->| B|------------>\n//      write(frame)  |  |  _receive()   |     _read()  |  |  read()\n//                    +--+               |              +--|\n//                    |                  |                 |\n//                    |                  |                 |\n//                    +------------------+                 |\n//                    |                                    |\n//                    +------------------------------------+\n//\n//     B: input or output buffer\n\nvar Flow = require('./flow').Flow;\n\nStream.prototype._initializeDataFlow = function _initializeDataFlow() {\n  this.id = undefined;\n\n  this._ended = false;\n\n  this.upstream = new Flow();\n  this.upstream._log = this._log;\n  this.upstream._send = this._send.bind(this);\n  this.upstream._receive = this._receive.bind(this);\n  this.upstream.write = this._writeUpstream.bind(this);\n  this.upstream.on('error', this.emit.bind(this, 'error'));\n\n  this.on('finish', this._finishing);\n};\n\nStream.prototype._pushUpstream = function _pushUpstream(frame) {\n  this.upstream.push(frame);\n  this._transition(true, frame);\n};\n\n// Overriding the upstream's `write` allows us to act immediately instead of waiting for the input\n// queue to empty. This is important in case of control frames.\nStream.prototype._writeUpstream = function _writeUpstream(frame) {\n  this._log.debug({ frame: frame }, 'Receiving frame');\n\n  var moreNeeded = Flow.prototype.write.call(this.upstream, frame);\n\n  // * Transition to a new state if that's the effect of receiving the frame\n  this._transition(false, frame);\n\n  // * If it's a control frame. Call the appropriate handler method.\n  if (frame.type === 'HEADERS') {\n    if (this._processedHeaders && !frame.flags['END_STREAM']) {\n      this.emit('error', 'PROTOCOL_ERROR');\n    }\n    this._processedHeaders = true;\n    this._onHeaders(frame);\n  } else if (frame.type === 'PUSH_PROMISE') {\n    this._onPromise(frame);\n  } else if (frame.type === 'PRIORITY') {\n    this._onPriority(frame);\n  } else if (frame.type === 'ALTSVC') {\n    // TODO\n  } else if (frame.type === 'BLOCKED') {\n    // TODO\n  }\n\n  // * If it's an invalid stream level frame, emit error\n  else if ((frame.type !== 'DATA') &&\n           (frame.type !== 'WINDOW_UPDATE') &&\n           (frame.type !== 'RST_STREAM')) {\n    this._log.error({ frame: frame }, 'Invalid stream level frame');\n    this.emit('error', 'PROTOCOL_ERROR');\n  }\n\n  return moreNeeded;\n};\n\n// The `_receive` method (= `upstream._receive`) gets called when there's an incoming frame.\nStream.prototype._receive = function _receive(frame, ready) {\n  // * If it's a DATA frame, then push the payload into the output buffer on the other side.\n  //   Call ready when the other side is ready to receive more.\n  if (!this._ended && (frame.type === 'DATA')) {\n    var moreNeeded = this.push(frame.data);\n    if (!moreNeeded) {\n      this._receiveMore = ready;\n    }\n  }\n\n  // * Any frame may signal the end of the stream with the END_STREAM flag\n  if (!this._ended && (frame.flags.END_STREAM || (frame.type === 'RST_STREAM'))) {\n    this.push(null);\n    this._ended = true;\n  }\n\n  // * Postpone calling `ready` if `push()` returned a falsy value\n  if (this._receiveMore !== ready) {\n    ready();\n  }\n};\n\n// The `_read` method is called when the user side is ready to receive more data. If there's a\n// pending write on the upstream, then call its pending ready callback to receive more frames.\nStream.prototype._read = function _read() {\n  if (this._receiveMore) {\n    var receiveMore = this._receiveMore;\n    delete this._receiveMore;\n    receiveMore();\n  }\n};\n\n// The `write` method gets called when there's a write request from the user.\nStream.prototype._write = function _write(buffer, encoding, ready) {\n  // * Chunking is done by the upstream Flow.\n  var moreNeeded = this._pushUpstream({\n    type: 'DATA',\n    flags: {},\n    stream: this.id,\n    data: buffer\n  });\n\n  // * Call ready when upstream is ready to receive more frames.\n  if (moreNeeded) {\n    ready();\n  } else {\n    this._sendMore = ready;\n  }\n};\n\n// The `_send` (= `upstream._send`) method is called when upstream is ready to receive more frames.\n// If there's a pending write on the user side, then call its pending ready callback to receive more\n// writes.\nStream.prototype._send = function _send() {\n  if (this._sendMore) {\n    var sendMore = this._sendMore;\n    delete this._sendMore;\n    sendMore();\n  }\n};\n\n// When the stream is finishing (the user calls `end()` on it), then we have to set the `END_STREAM`\n// flag on the last frame. If there's no frame in the queue, or if it doesn't support this flag,\n// then we create a 0 length DATA frame. We could do this all the time, but putting the flag on an\n// existing frame is a nice optimization.\nvar emptyBuffer = new Buffer(0);\nStream.prototype._finishing = function _finishing() {\n  var endFrame = {\n    type: 'DATA',\n    flags: { END_STREAM: true },\n    stream: this.id,\n    data: emptyBuffer\n  };\n  var lastFrame = this.upstream.getLastQueuedFrame();\n  if (lastFrame && ((lastFrame.type === 'DATA') || (lastFrame.type === 'HEADERS'))) {\n    this._log.debug({ frame: lastFrame }, 'Marking last frame with END_STREAM flag.');\n    lastFrame.flags.END_STREAM = true;\n    this._transition(true, endFrame);\n  } else {\n    this._pushUpstream(endFrame);\n  }\n};\n\n// [Stream States](https://tools.ietf.org/html/rfc7540#section-5.1)\n// ----------------\n//\n//                           +--------+\n//                     PP    |        |    PP\n//                  ,--------|  idle  |--------.\n//                 /         |        |         \\\n//                v          +--------+          v\n//         +----------+          |           +----------+\n//         |          |          | H         |          |\n//     ,---| reserved |          |           | reserved |---.\n//     |   | (local)  |          v           | (remote) |   |\n//     |   +----------+      +--------+      +----------+   |\n//     |      |          ES  |        |  ES          |      |\n//     |      | H    ,-------|  open  |-------.      | H    |\n//     |      |     /        |        |        \\     |      |\n//     |      v    v         +--------+         v    v      |\n//     |   +----------+          |           +----------+   |\n//     |   |   half   |          |           |   half   |   |\n//     |   |  closed  |          | R         |  closed  |   |\n//     |   | (remote) |          |           | (local)  |   |\n//     |   +----------+          |           +----------+   |\n//     |        |                v                 |        |\n//     |        |  ES / R    +--------+  ES / R    |        |\n//     |        `----------->|        |<-----------'        |\n//     |  R                  | closed |                  R  |\n//     `-------------------->|        |<--------------------'\n//                           +--------+\n\n// Streams begin in the IDLE state and transitions happen when there's an incoming or outgoing frame\nStream.prototype._initializeState = function _initializeState() {\n  this.state = 'IDLE';\n  this._initiated = undefined;\n  this._closedByUs = undefined;\n  this._closedWithRst = undefined;\n  this._processedHeaders = false;\n};\n\n// Only `_setState` should change `this.state` directly. It also logs the state change and notifies\n// interested parties using the 'state' event.\nStream.prototype._setState = function transition(state) {\n  assert(this.state !== state);\n  this._log.debug({ from: this.state, to: state }, 'State transition');\n  this.state = state;\n  this.emit('state', state);\n};\n\n// A state is 'active' if the stream in that state counts towards the concurrency limit. Streams\n// that are in the \"open\" state, or either of the \"half closed\" states count toward this limit.\nfunction activeState(state) {\n  return ((state === 'HALF_CLOSED_LOCAL') || (state === 'HALF_CLOSED_REMOTE') || (state === 'OPEN'));\n}\n\n// `_transition` is called every time there's an incoming or outgoing frame. It manages state\n// transitions, and detects stream errors. A stream error is always caused by a frame that is not\n// allowed in the current state.\nStream.prototype._transition = function transition(sending, frame) {\n  var receiving = !sending;\n  var connectionError;\n  var streamError;\n\n  var DATA = false, HEADERS = false, PRIORITY = false, ALTSVC = false, BLOCKED = false;\n  var RST_STREAM = false, PUSH_PROMISE = false, WINDOW_UPDATE = false;\n  switch(frame.type) {\n    case 'DATA'         : DATA          = true; break;\n    case 'HEADERS'      : HEADERS       = true; break;\n    case 'PRIORITY'     : PRIORITY      = true; break;\n    case 'RST_STREAM'   : RST_STREAM    = true; break;\n    case 'PUSH_PROMISE' : PUSH_PROMISE  = true; break;\n    case 'WINDOW_UPDATE': WINDOW_UPDATE = true; break;\n    case 'ALTSVC'       : ALTSVC        = true; break;\n    case 'BLOCKED'      : BLOCKED       = true; break;\n  }\n\n  var previousState = this.state;\n\n  switch (this.state) {\n    // All streams start in the **idle** state. In this state, no frames have been exchanged.\n    //\n    // * Sending or receiving a HEADERS frame causes the stream to become \"open\".\n    //\n    // When the HEADERS frame contains the END_STREAM flags, then two state transitions happen.\n    case 'IDLE':\n      if (HEADERS) {\n        this._setState('OPEN');\n        if (frame.flags.END_STREAM) {\n          this._setState(sending ? 'HALF_CLOSED_LOCAL' : 'HALF_CLOSED_REMOTE');\n        }\n        this._initiated = sending;\n      } else if (sending && RST_STREAM) {\n        this._setState('CLOSED');\n      } else if (PRIORITY) {\n        /* No state change */\n      } else {\n        connectionError = 'PROTOCOL_ERROR';\n      }\n      break;\n\n    // A stream in the **reserved (local)** state is one that has been promised by sending a\n    // PUSH_PROMISE frame.\n    //\n    // * The endpoint can send a HEADERS frame. This causes the stream to open in a \"half closed\n    //   (remote)\" state.\n    // * Either endpoint can send a RST_STREAM frame to cause the stream to become \"closed\". This\n    //   releases the stream reservation.\n    // * An endpoint may receive PRIORITY frame in this state.\n    // * An endpoint MUST NOT send any other type of frame in this state.\n    case 'RESERVED_LOCAL':\n      if (sending && HEADERS) {\n        this._setState('HALF_CLOSED_REMOTE');\n      } else if (RST_STREAM) {\n        this._setState('CLOSED');\n      } else if (PRIORITY) {\n        /* No state change */\n      } else {\n        connectionError = 'PROTOCOL_ERROR';\n      }\n      break;\n\n    // A stream in the **reserved (remote)** state has been reserved by a remote peer.\n    //\n    // * Either endpoint can send a RST_STREAM frame to cause the stream to become \"closed\". This\n    //   releases the stream reservation.\n    // * Receiving a HEADERS frame causes the stream to transition to \"half closed (local)\".\n    // * An endpoint MAY send PRIORITY frames in this state to reprioritize the stream.\n    // * Receiving any other type of frame MUST be treated as a stream error of type PROTOCOL_ERROR.\n    case 'RESERVED_REMOTE':\n      if (RST_STREAM) {\n        this._setState('CLOSED');\n      } else if (receiving && HEADERS) {\n        this._setState('HALF_CLOSED_LOCAL');\n      } else if (BLOCKED || PRIORITY) {\n        /* No state change */\n      } else {\n        connectionError = 'PROTOCOL_ERROR';\n      }\n      break;\n\n    // The **open** state is where both peers can send frames. In this state, sending peers observe\n    // advertised stream level flow control limits.\n    //\n    // * From this state either endpoint can send a frame with a END_STREAM flag set, which causes\n    //   the stream to transition into one of the \"half closed\" states: an endpoint sending a\n    //   END_STREAM flag causes the stream state to become \"half closed (local)\"; an endpoint\n    //   receiving a END_STREAM flag causes the stream state to become \"half closed (remote)\".\n    // * Either endpoint can send a RST_STREAM frame from this state, causing it to transition\n    //   immediately to \"closed\".\n    case 'OPEN':\n      if (frame.flags.END_STREAM) {\n        this._setState(sending ? 'HALF_CLOSED_LOCAL' : 'HALF_CLOSED_REMOTE');\n      } else if (RST_STREAM) {\n        this._setState('CLOSED');\n      } else {\n        /* No state change */\n      }\n      break;\n\n    // A stream that is **half closed (local)** cannot be used for sending frames.\n    //\n    // * A stream transitions from this state to \"closed\" when a frame that contains a END_STREAM\n    //   flag is received, or when either peer sends a RST_STREAM frame.\n    // * An endpoint MAY send or receive PRIORITY frames in this state to reprioritize the stream.\n    // * WINDOW_UPDATE can be sent by a peer that has sent a frame bearing the END_STREAM flag.\n    case 'HALF_CLOSED_LOCAL':\n      if (RST_STREAM || (receiving && frame.flags.END_STREAM)) {\n        this._setState('CLOSED');\n      } else if (BLOCKED || ALTSVC || receiving || PRIORITY || (sending && WINDOW_UPDATE)) {\n        /* No state change */\n      } else {\n        connectionError = 'PROTOCOL_ERROR';\n      }\n      break;\n\n    // A stream that is **half closed (remote)** is no longer being used by the peer to send frames.\n    // In this state, an endpoint is no longer obligated to maintain a receiver flow control window\n    // if it performs flow control.\n    //\n    // * If an endpoint receives additional frames for a stream that is in this state it MUST\n    //   respond with a stream error of type STREAM_CLOSED.\n    // * A stream can transition from this state to \"closed\" by sending a frame that contains a\n    //   END_STREAM flag, or when either peer sends a RST_STREAM frame.\n    // * An endpoint MAY send or receive PRIORITY frames in this state to reprioritize the stream.\n    // * A receiver MAY receive a WINDOW_UPDATE frame on a \"half closed (remote)\" stream.\n    case 'HALF_CLOSED_REMOTE':\n      if (RST_STREAM || (sending && frame.flags.END_STREAM)) {\n        this._setState('CLOSED');\n      } else if (BLOCKED || ALTSVC || sending || PRIORITY || (receiving && WINDOW_UPDATE)) {\n        /* No state change */\n      } else {\n        connectionError = 'PROTOCOL_ERROR';\n      }\n      break;\n\n    // The **closed** state is the terminal state.\n    //\n    // * An endpoint MUST NOT send frames on a closed stream. An endpoint that receives a frame\n    //   after receiving a RST_STREAM or a frame containing a END_STREAM flag on that stream MUST\n    //   treat that as a stream error of type STREAM_CLOSED.\n    // * WINDOW_UPDATE, PRIORITY or RST_STREAM frames can be received in this state for a short\n    //   period after a frame containing an END_STREAM flag is sent.  Until the remote peer receives\n    //   and processes the frame bearing the END_STREAM flag, it might send either frame type.\n    //   Endpoints MUST ignore WINDOW_UPDATE frames received in this state, though endpoints MAY\n    //   choose to treat WINDOW_UPDATE frames that arrive a significant time after sending\n    //   END_STREAM as a connection error of type PROTOCOL_ERROR.\n    // * If this state is reached as a result of sending a RST_STREAM frame, the peer that receives\n    //   the RST_STREAM might have already sent - or enqueued for sending - frames on the stream\n    //   that cannot be withdrawn. An endpoint that sends a RST_STREAM frame MUST ignore frames that\n    //   it receives on closed streams after it has sent a RST_STREAM frame. An endpoint MAY choose\n    //   to limit the period over which it ignores frames and treat frames that arrive after this\n    //   time as being in error.\n    // * An endpoint might receive a PUSH_PROMISE frame after it sends RST_STREAM. PUSH_PROMISE\n    //   causes a stream to become \"reserved\". If promised streams are not desired, a RST_STREAM\n    //   can be used to close any of those streams.\n    case 'CLOSED':\n      if (PRIORITY || (sending && RST_STREAM) ||\n          (receiving && WINDOW_UPDATE) ||\n          (receiving && this._closedByUs &&\n           (this._closedWithRst || RST_STREAM || ALTSVC))) {\n        /* No state change */\n      } else {\n        streamError = 'STREAM_CLOSED';\n      }\n      break;\n  }\n\n  // Noting that the connection was closed by the other endpoint. It may be important in edge cases.\n  // For example, when the peer tries to cancel a promised stream, but we already sent every data\n  // on it, then the stream is in CLOSED state, yet we want to ignore the incoming RST_STREAM.\n  if ((this.state === 'CLOSED') && (previousState !== 'CLOSED')) {\n    this._closedByUs = sending;\n    this._closedWithRst = RST_STREAM;\n  }\n\n  // Sending/receiving a PUSH_PROMISE\n  //\n  // * Sending a PUSH_PROMISE frame marks the associated stream for later use. The stream state\n  //   for the reserved stream transitions to \"reserved (local)\".\n  // * Receiving a PUSH_PROMISE frame marks the associated stream as reserved by the remote peer.\n  //   The state of the stream becomes \"reserved (remote)\".\n  if (PUSH_PROMISE && !connectionError && !streamError) {\n    /* This assertion must hold, because _transition is called immediately when a frame is written\n       to the stream. If it would be called when a frame gets out of the input queue, the state\n       of the reserved could have been changed by then. */\n    assert(frame.promised_stream.state === 'IDLE', frame.promised_stream.state);\n    frame.promised_stream._setState(sending ? 'RESERVED_LOCAL' : 'RESERVED_REMOTE');\n    frame.promised_stream._initiated = sending;\n  }\n\n  // Signaling how sending/receiving this frame changes the active stream count (-1, 0 or +1)\n  if (this._initiated) {\n    var change = (activeState(this.state) - activeState(previousState));\n    if (sending) {\n      frame.count_change = change;\n    } else {\n      frame.count_change(change);\n    }\n  } else if (sending) {\n    frame.count_change = 0;\n  }\n\n  // Common error handling.\n  if (connectionError || streamError) {\n    var info = {\n      error: connectionError,\n      frame: frame,\n      state: this.state,\n      closedByUs: this._closedByUs,\n      closedWithRst: this._closedWithRst\n    };\n\n    // * When sending something invalid, throwing an exception, since it is probably a bug.\n    if (sending) {\n      this._log.error(info, 'Sending illegal frame.');\n      return this.emit('error', new Error('Sending illegal frame (' + frame.type + ') in ' + this.state + ' state.'));\n    }\n\n    // * In case of a serious problem, emitting and error and letting someone else handle it\n    //   (e.g. closing the connection)\n    // * When receiving something invalid, sending an RST_STREAM using the `reset` method.\n    //   This will automatically cause a transition to the CLOSED state.\n    else {\n      this._log.error(info, 'Received illegal frame.');\n      if (connectionError) {\n        this.emit('connectionError', connectionError);\n      } else {\n        this.reset(streamError);\n        this.emit('error', streamError);\n      }\n    }\n  }\n};\n\n// Bunyan serializers\n// ------------------\n\nexports.serializers = {};\n\nvar nextId = 0;\nexports.serializers.s = function(stream) {\n  if (!('_id' in stream)) {\n    stream._id = nextId;\n    nextId += 1;\n  }\n  return stream._id;\n};\n"}